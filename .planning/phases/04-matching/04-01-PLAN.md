---
phase: 04-matching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/matching/queries.ts
  - convex/matching/mutations.ts
autonomous: true

must_haves:
  truths:
    - "Match results can be stored with tier, score, explanation, probability, and recommendations"
    - "Profile data can be fetched for matching context construction"
    - "Opportunities can be filtered by status and privacy settings"
    - "Matches can be saved and cleared for a profile"
  artifacts:
    - path: "convex/schema.ts"
      provides: "matches table definition"
      contains: "matches: defineTable"
    - path: "convex/matching/queries.ts"
      provides: "Internal queries for matching data"
      exports: ["getFullProfile", "getCandidateOpportunities"]
    - path: "convex/matching/mutations.ts"
      provides: "Internal mutations for match storage"
      exports: ["saveMatches", "clearMatchesForProfile"]
  key_links:
    - from: "convex/matching/queries.ts"
      to: "convex/schema.ts"
      via: "profiles and opportunities table access"
      pattern: "ctx\\.db\\.(get|query)"
    - from: "convex/matching/mutations.ts"
      to: "convex/schema.ts"
      via: "matches table writes"
      pattern: "ctx\\.db\\.(insert|delete)"
---

<objective>
Create the data layer foundation for the matching system: schema definition for matches table and internal queries/mutations for data access.

Purpose: Establish the database schema and data access layer that the match compute engine will use to store and retrieve match results.
Output: Schema update with matches table, internal queries for fetching profile/opportunity data, internal mutations for persisting match results.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-matching/04-RESEARCH.md
@.planning/phases/04-matching/04-CONTEXT.md
@convex/schema.ts
@convex/enrichment/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add matches table to schema</name>
  <files>convex/schema.ts</files>
  <action>
Add a new `matches` table to the schema with the following structure:

```typescript
matches: defineTable({
  profileId: v.id("profiles"),
  opportunityId: v.id("opportunities"),

  // Scoring (per CONTEXT.md: tier labels not percentages)
  tier: v.union(v.literal("great"), v.literal("good"), v.literal("exploring")),
  score: v.number(),  // 0-100 internal score for sorting within tier

  // Explanation (MATCH-02: bullet points with strengths + actionable gap)
  explanation: v.object({
    strengths: v.array(v.string()),    // 2-4 bullet points on why this fits
    gap: v.optional(v.string()),       // One actionable thing to strengthen application
  }),

  // Probability (MATCH-03: dual framing with experimental label)
  probability: v.object({
    interviewChance: v.string(),       // "Strong chance", "Good chance", "Moderate chance"
    ranking: v.string(),               // "Top 10%", "Top 20%", etc.
    confidence: v.string(),            // "HIGH", "MEDIUM", "LOW"
  }),

  // Recommendations (MATCH-04: 1 specific + 1-2 general per match)
  recommendations: v.array(v.object({
    type: v.union(v.literal("specific"), v.literal("skill"), v.literal("experience")),
    action: v.string(),
    priority: v.union(v.literal("high"), v.literal("medium"), v.literal("low")),
  })),

  // Metadata
  isNew: v.boolean(),                  // For "new high-fit" prioritization
  computedAt: v.number(),
  modelVersion: v.string(),            // Track which model version generated this
})
  .index("by_profile", ["profileId"])
  .index("by_profile_tier", ["profileId", "tier"])
  .index("by_opportunity", ["opportunityId"])
  .index("by_profile_new", ["profileId", "isNew"])
```

Place this after the existing `organizations` table definition.
  </action>
  <verify>Run `npx convex dev --once` - schema should push without errors</verify>
  <done>matches table exists with all required fields and indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create internal queries for matching data access</name>
  <files>convex/matching/queries.ts</files>
  <action>
Create a new file `convex/matching/queries.ts` with internal queries following the pattern from `enrichment/queries.ts`:

```typescript
import { internalQuery } from "../_generated/server";
import { v } from "convex/values";

// Get full profile data for context construction
export const getFullProfile = internalQuery({
  args: { profileId: v.id("profiles") },
  handler: async (ctx, { profileId }) => {
    const profile = await ctx.db.get(profileId);
    if (!profile) return null;

    return {
      _id: profile._id,
      name: profile.name,
      pronouns: profile.pronouns,
      location: profile.location,
      headline: profile.headline,
      education: profile.education || [],
      workHistory: profile.workHistory || [],
      skills: profile.skills || [],
      careerGoals: profile.careerGoals,
      aiSafetyInterests: profile.aiSafetyInterests || [],
      seeking: profile.seeking,
      enrichmentSummary: profile.enrichmentSummary,
      hasEnrichmentConversation: profile.hasEnrichmentConversation,
      privacySettings: profile.privacySettings,
    };
  },
});

// Get candidate opportunities for matching (excludes hidden orgs, expired, archived)
export const getCandidateOpportunities = internalQuery({
  args: {
    hiddenOrgs: v.array(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, { hiddenOrgs, limit }) => {
    const now = Date.now();

    // Get active opportunities
    let opportunities = await ctx.db
      .query("opportunities")
      .withIndex("by_status", q => q.eq("status", "active"))
      .collect();

    // Filter out:
    // 1. Organizations the user has hidden from their profile
    // 2. Expired opportunities (deadline passed)
    opportunities = opportunities.filter(opp => {
      // Check hidden orgs
      if (hiddenOrgs.includes(opp.organization)) return false;

      // Check deadline (only filter if deadline exists and has passed)
      if (opp.deadline && opp.deadline < now) return false;

      return true;
    });

    // Apply limit if specified
    if (limit) {
      opportunities = opportunities.slice(0, limit);
    }

    return opportunities;
  },
});

// Get existing matches for a profile (for staleness check)
export const getExistingMatches = internalQuery({
  args: { profileId: v.id("profiles") },
  handler: async (ctx, { profileId }) => {
    return await ctx.db
      .query("matches")
      .withIndex("by_profile", q => q.eq("profileId", profileId))
      .collect();
  },
});

// Get profile by userId (for public query to find profile)
export const getProfileByUserId = internalQuery({
  args: { userId: v.string() },
  handler: async (ctx, { userId }) => {
    return await ctx.db
      .query("profiles")
      .withIndex("by_user", q => q.eq("userId", userId))
      .first();
  },
});
```

This follows the pattern from enrichment/queries.ts but provides data specifically for matching context.
  </action>
  <verify>Run `npx convex dev --once` - file should be recognized and types generated</verify>
  <done>Internal queries available: getFullProfile, getCandidateOpportunities, getExistingMatches, getProfileByUserId</done>
</task>

<task type="auto">
  <name>Task 3: Create internal mutations for match storage</name>
  <files>convex/matching/mutations.ts</files>
  <action>
Create a new file `convex/matching/mutations.ts` with internal mutations for storing match results:

```typescript
import { internalMutation } from "../_generated/server";
import { v } from "convex/values";

// Match result type from LLM
const matchResultValidator = v.object({
  opportunityId: v.id("opportunities"),
  tier: v.union(v.literal("great"), v.literal("good"), v.literal("exploring")),
  score: v.number(),
  strengths: v.array(v.string()),
  gap: v.optional(v.string()),
  interviewChance: v.string(),
  ranking: v.string(),
  confidence: v.string(),
  recommendations: v.array(v.object({
    type: v.union(v.literal("specific"), v.literal("skill"), v.literal("experience")),
    action: v.string(),
    priority: v.union(v.literal("high"), v.literal("medium"), v.literal("low")),
  })),
});

// Save batch of matches for a profile
export const saveMatches = internalMutation({
  args: {
    profileId: v.id("profiles"),
    matches: v.array(matchResultValidator),
    modelVersion: v.string(),
  },
  handler: async (ctx, { profileId, matches, modelVersion }) => {
    const now = Date.now();

    // Get existing match opportunity IDs to determine which are "new"
    const existingMatches = await ctx.db
      .query("matches")
      .withIndex("by_profile", q => q.eq("profileId", profileId))
      .collect();

    const existingOppIds = new Set(existingMatches.map(m => m.opportunityId));

    // Delete old matches for this profile
    for (const match of existingMatches) {
      await ctx.db.delete(match._id);
    }

    // Insert new matches
    for (const match of matches) {
      const isNew = !existingOppIds.has(match.opportunityId);

      await ctx.db.insert("matches", {
        profileId,
        opportunityId: match.opportunityId,
        tier: match.tier,
        score: match.score,
        explanation: {
          strengths: match.strengths,
          gap: match.gap,
        },
        probability: {
          interviewChance: match.interviewChance,
          ranking: match.ranking,
          confidence: match.confidence,
        },
        recommendations: match.recommendations,
        isNew,
        computedAt: now,
        modelVersion,
      });
    }

    return { savedCount: matches.length };
  },
});

// Clear all matches for a profile (used before recomputation)
export const clearMatchesForProfile = internalMutation({
  args: { profileId: v.id("profiles") },
  handler: async (ctx, { profileId }) => {
    const matches = await ctx.db
      .query("matches")
      .withIndex("by_profile", q => q.eq("profileId", profileId))
      .collect();

    for (const match of matches) {
      await ctx.db.delete(match._id);
    }

    return { deletedCount: matches.length };
  },
});

// Mark matches as not new (after user has viewed them)
export const markMatchesViewed = internalMutation({
  args: { profileId: v.id("profiles") },
  handler: async (ctx, { profileId }) => {
    const newMatches = await ctx.db
      .query("matches")
      .withIndex("by_profile_new", q => q.eq("profileId", profileId).eq("isNew", true))
      .collect();

    for (const match of newMatches) {
      await ctx.db.patch(match._id, { isNew: false });
    }

    return { markedCount: newMatches.length };
  },
});
```

This provides the storage layer that the compute action will use to persist LLM-generated matches.
  </action>
  <verify>Run `npx convex dev --once` - file should be recognized and types generated</verify>
  <done>Internal mutations available: saveMatches, clearMatchesForProfile, markMatchesViewed</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx convex dev --once` succeeds with no errors
2. Schema includes matches table with proper indexes
3. `internal.matching.queries.*` functions are accessible
4. `internal.matching.mutations.*` functions are accessible
5. Generated types in convex/_generated/ include matches table
</verification>

<success_criteria>
- matches table schema defined with tier, score, explanation, probability, recommendations fields
- Internal queries can fetch profile and opportunity data for context construction
- Internal mutations can save, clear, and update match records
- All indexes support efficient querying by profile and tier
- Code follows existing patterns (enrichment/queries.ts style)
</success_criteria>

<output>
After completion, create `.planning/phases/04-matching/04-01-SUMMARY.md`
</output>
