---
phase: 04-matching
plan: 02
type: execute
wave: 2
depends_on: ['04-01']
files_modified:
  - convex/matching/prompts.ts
  - convex/matching/compute.ts
  - convex/matches.ts
autonomous: true

must_haves:
  truths:
    - 'Profile context can be constructed programmatically for LLM input'
    - 'Opportunities are batch-scored in a single LLM call with forced tool_choice'
    - 'Match results include tier, explanation, probability, and recommendations'
    - 'Public queries return matches grouped by tier for authenticated users'
  artifacts:
    - path: 'convex/matching/prompts.ts'
      provides: 'System prompt, context builders, and tool definition'
      exports:
        [
          'MATCHING_SYSTEM_PROMPT',
          'buildProfileContext',
          'buildOpportunitiesContext',
          'matchOpportunitiesTool',
        ]
    - path: 'convex/matching/compute.ts'
      provides: 'Node.js action for LLM matching'
      exports: ['computeMatchesForProfile']
    - path: 'convex/matches.ts'
      provides: 'Public queries for UI consumption'
      exports: ['getMyMatches', 'getMatchById', 'triggerMatchComputation']
  key_links:
    - from: 'convex/matching/compute.ts'
      to: 'convex/matching/queries.ts'
      via: 'internal query calls'
      pattern: "ctx\\.runQuery\\(internal\\.matching\\.queries"
    - from: 'convex/matching/compute.ts'
      to: 'convex/matching/mutations.ts'
      via: 'internal mutation calls'
      pattern: "ctx\\.runMutation\\(internal\\.matching\\.mutations"
    - from: 'convex/matching/compute.ts'
      to: '@anthropic-ai/sdk'
      via: 'Anthropic API call with forced tool_choice'
      pattern: 'tool_choice.*type.*tool'
    - from: 'convex/matches.ts'
      to: 'convex/schema.ts'
      via: 'matches table queries'
      pattern: "ctx\\.db\\.query\\(\"matches\""
---

<objective>
Build the match compute engine that uses Claude to score opportunities against profiles with programmatic context construction and forced tool_choice for structured output.

Purpose: Create the core matching logic that takes a profile, constructs LLM context, batch-scores opportunities, and returns structured match results with explanations and recommendations.
Output: Prompts module, Node.js compute action, and public queries for UI consumption.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-matching/04-RESEARCH.md
@.planning/phases/04-matching/04-CONTEXT.md
@.planning/phases/04-matching/04-01-SUMMARY.md
@convex/enrichment/conversation.ts
@convex/enrichment/extraction.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create prompts and tool definitions</name>
  <files>convex/matching/prompts.ts</files>
  <action>
Create `convex/matching/prompts.ts` with the system prompt, context builders, and tool definition for structured output.

```typescript
import Anthropic from '@anthropic-ai/sdk'

// Types for profile and opportunity data
interface ProfileData {
  _id: string
  name?: string
  pronouns?: string
  location?: string
  headline?: string
  education: Array<{
    institution: string
    degree?: string
    field?: string
    startYear?: number
    endYear?: number
    current?: boolean
  }>
  workHistory: Array<{
    organization: string
    title: string
    startDate?: number
    endDate?: number
    current?: boolean
    description?: string
  }>
  skills: string[]
  careerGoals?: string
  aiSafetyInterests: string[]
  seeking?: string
  enrichmentSummary?: string
}

interface OpportunityData {
  _id: string
  title: string
  organization: string
  location: string
  isRemote: boolean
  roleType: string
  experienceLevel?: string
  description: string
  requirements?: string[]
  deadline?: number
}

// System prompt for matching (per CONTEXT.md: encouraging tone)
export const MATCHING_SYSTEM_PROMPT = `You are an AI career matching assistant for the AI Safety Talent Network. Your job is to match candidates with opportunities and provide helpful, encouraging feedback.

## Your Task
Analyze the candidate's profile against each opportunity and provide:
1. A match tier (great/good/exploring) based on overall fit
2. A numeric score (0-100) for sorting within tiers
3. 2-4 bullet points explaining why this opportunity fits the candidate (strengths)
4. One actionable thing that would strengthen their application (gap) - optional if near-perfect fit
5. Interview probability assessment (be realistic but encouraging)
6. 1 specific recommendation for this role + 1-2 general growth areas

## Tier Guidelines
- **great**: Strong alignment on skills, experience, and interests. Candidate would be competitive.
- **good**: Good alignment with some gaps. Candidate has a reasonable chance.
- **exploring**: Worth considering but significant gaps exist. Stretch opportunity.

Do NOT include opportunities where there's no reasonable fit at all.

## Tone
- Be encouraging and constructive ("This could be a strong fit because...")
- Be specific in recommendations ("Consider building experience with...")
- Be honest but not discouraging about gaps
- Frame probability assessments positively when possible

## Output
Use the score_opportunities tool to return structured results for ALL opportunities provided.`

// Build profile context string for LLM
export function buildProfileContext(profile: ProfileData): string {
  const sections: string[] = []

  sections.push('## Candidate Profile\n')

  // Basic info
  const basicInfo: string[] = []
  if (profile.name) basicInfo.push(`Name: ${profile.name}`)
  if (profile.location) basicInfo.push(`Location: ${profile.location}`)
  if (profile.headline) basicInfo.push(`Headline: ${profile.headline}`)
  if (basicInfo.length > 0) {
    sections.push('### Background')
    sections.push(basicInfo.join('\n'))
  }

  // Education
  if (profile.education.length > 0) {
    sections.push('\n### Education')
    for (const edu of profile.education) {
      const parts: string[] = []
      if (edu.degree && edu.field) {
        parts.push(`${edu.degree} in ${edu.field}`)
      } else if (edu.degree) {
        parts.push(edu.degree)
      } else if (edu.field) {
        parts.push(edu.field)
      }
      parts.push(`at ${edu.institution}`)
      if (edu.startYear) {
        const endStr = edu.current ? 'Present' : edu.endYear || ''
        parts.push(`(${edu.startYear} - ${endStr})`)
      }
      sections.push(`- ${parts.join(' ')}`)
    }
  }

  // Work history
  if (profile.workHistory.length > 0) {
    sections.push('\n### Work Experience')
    for (const work of profile.workHistory) {
      let entry = `- ${work.title} at ${work.organization}`
      if (work.startDate) {
        const startDate = new Date(work.startDate).toLocaleDateString('en-US', {
          month: 'short',
          year: 'numeric',
        })
        const endStr = work.current
          ? 'Present'
          : work.endDate
            ? new Date(work.endDate).toLocaleDateString('en-US', {
                month: 'short',
                year: 'numeric',
              })
            : ''
        entry += ` (${startDate} - ${endStr})`
      }
      sections.push(entry)
      if (work.description) {
        sections.push(`  ${work.description}`)
      }
    }
  }

  // Skills
  if (profile.skills.length > 0) {
    sections.push('\n### Skills')
    sections.push(profile.skills.join(', '))
  }

  // AI Safety interests
  if (profile.aiSafetyInterests.length > 0) {
    sections.push('\n### AI Safety Interests')
    sections.push(profile.aiSafetyInterests.join(', '))
  }

  // Career goals
  if (profile.careerGoals) {
    sections.push('\n### Career Goals')
    sections.push(profile.careerGoals)
  }

  // What they're seeking
  if (profile.seeking) {
    sections.push("\n### What They're Seeking")
    sections.push(profile.seeking)
  }

  // Enrichment summary (rich narrative context from LLM conversation)
  if (profile.enrichmentSummary) {
    sections.push('\n### Additional Context (from career conversation)')
    sections.push(profile.enrichmentSummary)
  }

  return sections.join('\n')
}

// Build opportunities context string for LLM
export function buildOpportunitiesContext(
  opportunities: OpportunityData[],
): string {
  const sections: string[] = []
  sections.push('## Opportunities to Match\n')

  for (const opp of opportunities) {
    sections.push(`### [${opp._id}] ${opp.title}`)
    sections.push(`Organization: ${opp.organization}`)
    sections.push(
      `Location: ${opp.location}${opp.isRemote ? ' (Remote available)' : ''}`,
    )
    sections.push(`Role Type: ${opp.roleType}`)
    if (opp.experienceLevel) {
      sections.push(`Experience Level: ${opp.experienceLevel}`)
    }
    sections.push(`\nDescription:\n${opp.description}`)
    if (opp.requirements && opp.requirements.length > 0) {
      sections.push('\nRequirements:')
      for (const req of opp.requirements) {
        sections.push(`- ${req}`)
      }
    }
    if (opp.deadline) {
      const deadlineDate = new Date(opp.deadline).toLocaleDateString('en-US', {
        month: 'long',
        day: 'numeric',
        year: 'numeric',
      })
      sections.push(`\nDeadline: ${deadlineDate}`)
    }
    sections.push('\n---\n')
  }

  return sections.join('\n')
}

// Tool definition for structured output (forced tool_choice)
export const matchOpportunitiesTool: Anthropic.Tool = {
  name: 'score_opportunities',
  description:
    'Score and explain how well opportunities match a candidate profile',
  input_schema: {
    type: 'object' as const,
    properties: {
      matches: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            opportunityId: {
              type: 'string',
              description: 'The opportunity ID from the input',
            },
            tier: {
              type: 'string',
              enum: ['great', 'good', 'exploring'],
              description: 'Match quality tier',
            },
            score: {
              type: 'number',
              description:
                'Numeric score 0-100 for sorting within tier (100 = best)',
            },
            strengths: {
              type: 'array',
              items: { type: 'string' },
              description: '2-4 bullet points on why this fits the candidate',
            },
            gap: {
              type: 'string',
              description:
                'One actionable thing that would strengthen the application (optional for near-perfect fits)',
            },
            interviewChance: {
              type: 'string',
              enum: ['Strong chance', 'Good chance', 'Moderate chance'],
              description: 'Likelihood of reaching interview stage',
            },
            ranking: {
              type: 'string',
              description:
                "Estimated percentile among applicants, e.g. 'Likely top 10%', 'Likely top 20%'",
            },
            confidence: {
              type: 'string',
              enum: ['HIGH', 'MEDIUM', 'LOW'],
              description: 'Confidence in the probability assessment',
            },
            recommendations: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  type: {
                    type: 'string',
                    enum: ['specific', 'skill', 'experience'],
                    description: 'Type of recommendation',
                  },
                  action: {
                    type: 'string',
                    description: 'The recommended action',
                  },
                  priority: {
                    type: 'string',
                    enum: ['high', 'medium', 'low'],
                    description: 'Priority level',
                  },
                },
                required: ['type', 'action', 'priority'],
              },
              description:
                '1 specific recommendation for this role + 1-2 general growth areas',
            },
          },
          required: [
            'opportunityId',
            'tier',
            'score',
            'strengths',
            'interviewChance',
            'ranking',
            'confidence',
            'recommendations',
          ],
        },
      },
      growthAreas: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            theme: {
              type: 'string',
              description:
                "Category like 'Skills to build', 'Experience to gain', 'Knowledge to deepen'",
            },
            items: {
              type: 'array',
              items: { type: 'string' },
              description: 'Specific growth items within this theme',
            },
          },
          required: ['theme', 'items'],
        },
        description:
          'Aggregated growth recommendations across all matches (3-5 themes)',
      },
    },
    required: ['matches', 'growthAreas'],
  },
}

// Type for the tool output
export interface MatchingResult {
  matches: Array<{
    opportunityId: string
    tier: 'great' | 'good' | 'exploring'
    score: number
    strengths: string[]
    gap?: string
    interviewChance: string
    ranking: string
    confidence: string
    recommendations: Array<{
      type: 'specific' | 'skill' | 'experience'
      action: string
      priority: 'high' | 'medium' | 'low'
    }>
  }>
  growthAreas: Array<{
    theme: string
    items: string[]
  }>
}
```

This provides all the building blocks for the compute action.
</action>
<verify>Run `npx convex dev --once` - file should compile without TypeScript errors</verify>
<done>prompts.ts exports MATCHING_SYSTEM_PROMPT, buildProfileContext, buildOpportunitiesContext, matchOpportunitiesTool, MatchingResult</done>
</task>

<task type="auto">
  <name>Task 2: Create compute action with LLM batch matching</name>
  <files>convex/matching/compute.ts</files>
  <action>
Create `convex/matching/compute.ts` as a Node.js action following the pattern from enrichment/conversation.ts:

```typescript
'use node'

import { action } from '../_generated/server'
import { internal } from '../_generated/api'
import { v } from 'convex/values'
import Anthropic from '@anthropic-ai/sdk'
import {
  MATCHING_SYSTEM_PROMPT,
  buildProfileContext,
  buildOpportunitiesContext,
  matchOpportunitiesTool,
  MatchingResult,
} from './prompts'
import { Id } from '../_generated/dataModel'

const MODEL_VERSION = 'claude-sonnet-4-5-20241022'
const BATCH_SIZE = 15 // Process up to 15 opportunities per LLM call

// Main compute action - scores all opportunities for a profile
export const computeMatchesForProfile = action({
  args: { profileId: v.id('profiles') },
  handler: async (ctx, { profileId }) => {
    // 1. Get profile with all fields
    const profile = await ctx.runQuery(
      internal.matching.queries.getFullProfile,
      { profileId },
    )
    if (!profile) {
      throw new Error('Profile not found')
    }

    // 2. Get candidate opportunities (excluding hidden orgs, expired)
    const hiddenOrgs = profile.privacySettings?.hiddenFromOrgs || []
    const opportunities = await ctx.runQuery(
      internal.matching.queries.getCandidateOpportunities,
      { hiddenOrgs, limit: 50 }, // Cap at 50 for pilot
    )

    if (opportunities.length === 0) {
      // No opportunities to match - clear existing matches
      await ctx.runMutation(
        internal.matching.mutations.clearMatchesForProfile,
        { profileId },
      )
      return { matchCount: 0, message: 'No active opportunities to match' }
    }

    // 3. Build context
    const profileContext = buildProfileContext(profile)

    // 4. Process in batches if needed
    const allMatches: MatchingResult['matches'] = []
    let aggregatedGrowthAreas: MatchingResult['growthAreas'] = []

    for (let i = 0; i < opportunities.length; i += BATCH_SIZE) {
      const batch = opportunities.slice(i, i + BATCH_SIZE)
      const opportunitiesContext = buildOpportunitiesContext(batch)

      // 5. Call Claude with forced tool_choice
      const anthropic = new Anthropic()
      const response = await anthropic.messages.create({
        model: MODEL_VERSION,
        max_tokens: 4096,
        tools: [matchOpportunitiesTool],
        tool_choice: { type: 'tool', name: 'score_opportunities' },
        system: MATCHING_SYSTEM_PROMPT,
        messages: [
          {
            role: 'user',
            content: `${profileContext}\n\n---\n\n${opportunitiesContext}\n\nScore all opportunities for this candidate. Include only opportunities with tier great, good, or exploring - skip any that have no reasonable fit.`,
          },
        ],
      })

      // 6. Extract tool use result
      const toolUse = response.content.find(
        (block) => block.type === 'tool_use',
      )
      if (!toolUse || toolUse.type !== 'tool_use') {
        console.error('No tool use in response for batch', i)
        continue
      }

      const batchResult = toolUse.input as MatchingResult

      // Map opportunityId strings back to actual Ids
      for (const match of batchResult.matches) {
        const oppId = match.opportunityId as Id<'opportunities'>
        // Verify the opportunity exists in our batch
        const validOpp = batch.find((o) => o._id === oppId)
        if (validOpp) {
          allMatches.push({
            ...match,
            opportunityId: oppId,
          })
        }
      }

      // Keep growth areas from last batch (most comprehensive view)
      if (batchResult.growthAreas.length > 0) {
        aggregatedGrowthAreas = batchResult.growthAreas
      }
    }

    // 7. Save all matches
    if (allMatches.length > 0) {
      await ctx.runMutation(internal.matching.mutations.saveMatches, {
        profileId,
        matches: allMatches.map((m) => ({
          opportunityId: m.opportunityId as Id<'opportunities'>,
          tier: m.tier,
          score: m.score,
          strengths: m.strengths,
          gap: m.gap,
          interviewChance: m.interviewChance,
          ranking: m.ranking,
          confidence: m.confidence,
          recommendations: m.recommendations,
        })),
        modelVersion: MODEL_VERSION,
      })
    }

    return {
      matchCount: allMatches.length,
      tiers: {
        great: allMatches.filter((m) => m.tier === 'great').length,
        good: allMatches.filter((m) => m.tier === 'good').length,
        exploring: allMatches.filter((m) => m.tier === 'exploring').length,
      },
      growthAreas: aggregatedGrowthAreas,
    }
  },
})
```

Key patterns used:

- `"use node"` directive for Anthropic SDK
- Internal queries via `ctx.runQuery(internal.matching.queries.xxx)`
- Internal mutations via `ctx.runMutation(internal.matching.mutations.xxx)`
- Forced tool_choice for guaranteed structured output
- Batch processing for large opportunity sets
  </action>
  <verify>Run `npx convex dev --once` - action should register without errors</verify>
  <done>computeMatchesForProfile action callable at api.matching.compute.computeMatchesForProfile</done>
  </task>

<task type="auto">
  <name>Task 3: Create public queries for UI consumption</name>
  <files>convex/matches.ts</files>
  <action>
Create `convex/matches.ts` with public queries and a trigger action for match computation:

```typescript
import { query, action } from './_generated/server'
import { internal, api } from './_generated/api'
import { v } from 'convex/values'
import { auth } from './auth'

// Get all matches for current user, grouped by tier
export const getMyMatches = query({
  args: {},
  handler: async (ctx) => {
    const userId = await auth.getUserId(ctx)
    if (!userId) {
      return null
    }

    // Get user's profile
    const profile = await ctx.db
      .query('profiles')
      .withIndex('by_user', (q) => q.eq('userId', userId))
      .first()

    if (!profile) {
      return { matches: [], needsProfile: true }
    }

    // Get matches for this profile
    const matches = await ctx.db
      .query('matches')
      .withIndex('by_profile', (q) => q.eq('profileId', profile._id))
      .collect()

    if (matches.length === 0) {
      return {
        matches: [],
        needsProfile: false,
        needsComputation: true,
        profileId: profile._id,
      }
    }

    // Enrich matches with opportunity data
    const enrichedMatches = await Promise.all(
      matches.map(async (match) => {
        const opportunity = await ctx.db.get(match.opportunityId)
        return {
          ...match,
          opportunity: opportunity
            ? {
                _id: opportunity._id,
                title: opportunity.title,
                organization: opportunity.organization,
                location: opportunity.location,
                isRemote: opportunity.isRemote,
                roleType: opportunity.roleType,
                experienceLevel: opportunity.experienceLevel,
                sourceUrl: opportunity.sourceUrl,
                deadline: opportunity.deadline,
              }
            : null,
        }
      }),
    )

    // Filter out matches where opportunity was deleted
    const validMatches = enrichedMatches.filter((m) => m.opportunity !== null)

    // Group by tier and sort by score within tier
    const grouped = {
      great: validMatches
        .filter((m) => m.tier === 'great')
        .sort((a, b) => b.score - a.score),
      good: validMatches
        .filter((m) => m.tier === 'good')
        .sort((a, b) => b.score - a.score),
      exploring: validMatches
        .filter((m) => m.tier === 'exploring')
        .sort((a, b) => b.score - a.score),
    }

    // Count new matches for badge
    const newMatchCount = validMatches.filter((m) => m.isNew).length

    // Get staleness (oldest computation time)
    const computedAt =
      matches.length > 0 ? Math.min(...matches.map((m) => m.computedAt)) : null

    return {
      matches: grouped,
      newMatchCount,
      computedAt,
      needsProfile: false,
      needsComputation: false,
      profileId: profile._id,
    }
  },
})

// Get a single match by ID with full details
export const getMatchById = query({
  args: { matchId: v.id('matches') },
  handler: async (ctx, { matchId }) => {
    const userId = await auth.getUserId(ctx)
    if (!userId) {
      return null
    }

    const match = await ctx.db.get(matchId)
    if (!match) {
      return null
    }

    // Verify ownership
    const profile = await ctx.db.get(match.profileId)
    if (!profile || profile.userId !== userId) {
      return null
    }

    // Get full opportunity data
    const opportunity = await ctx.db.get(match.opportunityId)
    if (!opportunity) {
      return null
    }

    return {
      ...match,
      opportunity,
    }
  },
})

// Get match count for navigation badge
export const getNewMatchCount = query({
  args: {},
  handler: async (ctx) => {
    const userId = await auth.getUserId(ctx)
    if (!userId) {
      return 0
    }

    const profile = await ctx.db
      .query('profiles')
      .withIndex('by_user', (q) => q.eq('userId', userId))
      .first()

    if (!profile) {
      return 0
    }

    const newMatches = await ctx.db
      .query('matches')
      .withIndex('by_profile_new', (q) =>
        q.eq('profileId', profile._id).eq('isNew', true),
      )
      .collect()

    return newMatches.length
  },
})

// Trigger match computation (called from UI when needed)
export const triggerMatchComputation = action({
  args: {},
  handler: async (ctx) => {
    const userId = await auth.getUserId(ctx)
    if (!userId) {
      throw new Error('Not authenticated')
    }

    // Get profile
    const profile = await ctx.runQuery(
      internal.matching.queries.getProfileByUserId,
      { userId },
    )

    if (!profile) {
      throw new Error('Profile not found - please create a profile first')
    }

    // Trigger computation
    const result = await ctx.runAction(
      api.matching.compute.computeMatchesForProfile,
      { profileId: profile._id },
    )

    return result
  },
})

// Mark matches as viewed (clear "new" badge)
export const markMatchesViewed = action({
  args: {},
  handler: async (ctx) => {
    const userId = await auth.getUserId(ctx)
    if (!userId) {
      throw new Error('Not authenticated')
    }

    const profile = await ctx.runQuery(
      internal.matching.queries.getProfileByUserId,
      { userId },
    )

    if (!profile) {
      return { markedCount: 0 }
    }

    const result = await ctx.runMutation(
      internal.matching.mutations.markMatchesViewed,
      { profileId: profile._id },
    )

    return result
  },
})
```

This provides:

- `getMyMatches` - Main query for matches list page, returns grouped by tier
- `getMatchById` - Single match query for detail page
- `getNewMatchCount` - For navigation badge
- `triggerMatchComputation` - Action to kick off matching
- `markMatchesViewed` - Clear "new" status after viewing
  </action>
  <verify>Run `npx convex dev --once` - queries and actions should register. Test with `npx convex run matches:getMyMatches` (will return null for unauthenticated)</verify>
  <done>Public API available: api.matches.getMyMatches, api.matches.getMatchById, api.matches.getNewMatchCount, api.matches.triggerMatchComputation, api.matches.markMatchesViewed</done>
  </task>

</tasks>

<verification>
After all tasks complete:
1. `npx convex dev --once` succeeds with no errors
2. All exports from prompts.ts are usable in compute.ts
3. `computeMatchesForProfile` action can be invoked (will need a valid profileId to test fully)
4. Public queries are accessible via api.matches.*
5. Type checking passes for all files
</verification>

<success_criteria>

- Programmatic context construction builds rich profile + opportunity strings
- LLM call uses forced tool_choice for guaranteed structured output
- Match results include tier, score, explanation, probability, recommendations (MATCH-01, 02, 03, 04)
- Batch processing handles up to 50 opportunities efficiently
- Public queries return data in UI-ready format (grouped by tier)
- Trigger action allows UI to initiate computation
  </success_criteria>

<output>
After completion, create `.planning/phases/04-matching/04-02-SUMMARY.md`
</output>
