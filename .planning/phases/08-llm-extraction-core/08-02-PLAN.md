---
phase: 08-llm-extraction-core
plan: 02
type: execute
wave: 2
depends_on: ['08-01']
files_modified:
  - convex/extraction/pdf.ts
  - convex/extraction/text.ts
  - convex/extraction/mutations.ts
autonomous: true

must_haves:
  truths:
    - 'PDF extraction retrieves file from Convex storage and sends to Claude'
    - 'Text extraction processes pasted text through same extraction logic'
    - 'Extraction automatically retries 2-3x with exponential backoff on failure'
    - 'Extraction results are persisted to uploadedDocuments table'
  artifacts:
    - path: 'convex/extraction/pdf.ts'
      provides: 'PDF extraction action'
      exports: ['extractFromPdf']
    - path: 'convex/extraction/text.ts'
      provides: 'Text extraction action'
      exports: ['extractFromText']
    - path: 'convex/extraction/mutations.ts'
      provides: 'Mutations for saving extraction results'
      exports: ['saveExtractionResult', 'updateDocumentStatus']
  key_links:
    - from: 'convex/extraction/pdf.ts'
      to: 'ctx.storage.get'
      via: 'Convex storage API'
      pattern: "ctx\\.storage\\.get"
    - from: 'convex/extraction/pdf.ts'
      to: 'anthropic.messages.create'
      via: 'Claude API client'
      pattern: "anthropic\\.messages\\.create"
    - from: 'convex/extraction/pdf.ts'
      to: 'convex/extraction/prompts.ts'
      via: 'import tool definition'
      pattern: 'import.*extractProfileTool'
    - from: 'convex/extraction/pdf.ts'
      to: 'convex/extraction/skills.ts'
      via: 'import skill matching'
      pattern: 'import.*matchSkillsToTaxonomy'
---

<objective>
Build the extraction actions that call Claude Haiku 4.5 to extract structured data from PDFs and pasted text.

Purpose: Enable the system to transform uploaded documents into structured profile data.
Output: Working PDF and text extraction actions with retry logic and result persistence.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-llm-extraction-core/08-CONTEXT.md
@.planning/phases/08-llm-extraction-core/08-RESEARCH.md
@.planning/phases/08-llm-extraction-core/08-01-SUMMARY.md
@convex/extraction/prompts.ts
@convex/extraction/skills.ts
@convex/enrichment/extraction.ts
@convex/matching/compute.ts
@convex/upload.ts
@convex/skills.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PDF extraction action</name>
  <files>convex/extraction/pdf.ts</files>
  <action>
Create convex/extraction/pdf.ts with "use node" directive at top.

Implement extractFromPdf action:

```typescript
'use node'

import { v } from 'convex/values'
import Anthropic from '@anthropic-ai/sdk'
import { action } from '../_generated/server'
import { internal } from '../_generated/api'
import { extractProfileTool, EXTRACTION_SYSTEM_PROMPT } from './prompts'
import type { ExtractionResult } from './prompts'
import { matchSkillsToTaxonomy } from './skills'

const MODEL_VERSION = 'claude-haiku-4-5-20251001'
const MAX_RETRIES = 3

export const extractFromPdf = action({
  args: { documentId: v.id('uploadedDocuments') },
  handler: async (ctx, { documentId }) => {
    // 1. Update status to "extracting"
    await ctx.runMutation(internal.extraction.mutations.updateDocumentStatus, {
      documentId,
      status: 'extracting',
    })

    try {
      // 2. Get document record to find storageId
      const doc = await ctx.runQuery(internal.extraction.queries.getDocument, {
        documentId,
      })
      if (!doc) throw new Error('Document not found')

      // 3. Get file blob from storage
      const blob = await ctx.storage.get(doc.storageId)
      if (!blob) throw new Error('File not found in storage')

      // 4. Convert blob to base64
      const arrayBuffer = await blob.arrayBuffer()
      const buffer = Buffer.from(arrayBuffer)
      const base64 = buffer.toString('base64')

      // 5. Call Claude with retry logic
      const extractedData = await extractWithRetry(base64)

      // 6. Match skills to taxonomy
      const taxonomy = await ctx.runQuery(
        internal.extraction.queries.getSkillsTaxonomy,
      )
      const matchedSkills = matchSkillsToTaxonomy(
        extractedData.rawSkills || [],
        taxonomy,
      )

      // 7. Save results
      await ctx.runMutation(
        internal.extraction.mutations.saveExtractionResult,
        {
          documentId,
          extractedData: {
            ...extractedData,
            skills: matchedSkills,
          },
        },
      )

      return {
        success: true,
        extractedData: { ...extractedData, skills: matchedSkills },
      }
    } catch (error) {
      // Mark as failed
      await ctx.runMutation(
        internal.extraction.mutations.updateDocumentStatus,
        {
          documentId,
          status: 'failed',
          errorMessage:
            error instanceof Error ? error.message : 'Extraction failed',
        },
      )
      throw error
    }
  },
})

async function extractWithRetry(pdfBase64: string): Promise<ExtractionResult> {
  const anthropic = new Anthropic()
  let lastError: Error | null = null

  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
    try {
      const response = await anthropic.messages.create({
        model: MODEL_VERSION,
        max_tokens: 4096,
        tools: [extractProfileTool],
        tool_choice: { type: 'tool', name: 'extract_profile_info' },
        system: EXTRACTION_SYSTEM_PROMPT,
        messages: [
          {
            role: 'user',
            content: [
              {
                type: 'document',
                source: {
                  type: 'base64',
                  media_type: 'application/pdf',
                  data: pdfBase64,
                },
              },
              {
                type: 'text',
                text: 'Extract the profile information from this resume/CV document.',
              },
            ],
          },
        ],
      })

      const toolUse = response.content.find(
        (block) => block.type === 'tool_use',
      )
      if (!toolUse || toolUse.type !== 'tool_use') {
        throw new Error('No tool use in Claude response')
      }

      return toolUse.input as ExtractionResult
    } catch (error) {
      lastError = error as Error
      if (attempt < MAX_RETRIES - 1) {
        // Exponential backoff: 1s, 2s, 4s
        await new Promise((resolve) =>
          setTimeout(resolve, Math.pow(2, attempt) * 1000),
        )
      }
    }
  }

  throw lastError || new Error('Extraction failed after retries')
}
```

Note: The internal queries (getDocument, getSkillsTaxonomy) will be created in Task 3.
</action>
<verify>Run `bun run lint` - TypeScript should compile (may have errors for missing queries until Task 3)</verify>
<done>extractFromPdf action retrieves PDF from storage, sends to Claude with document content block, extracts structured data with retry logic</done>
</task>

<task type="auto">
  <name>Task 2: Create text extraction action</name>
  <files>convex/extraction/text.ts</files>
  <action>
Create convex/extraction/text.ts with "use node" directive.

Implement extractFromText action - similar to PDF but accepts raw text instead of documentId:

```typescript
'use node'

import { v } from 'convex/values'
import Anthropic from '@anthropic-ai/sdk'
import { action } from '../_generated/server'
import { internal } from '../_generated/api'
import { extractProfileTool, EXTRACTION_SYSTEM_PROMPT } from './prompts'
import type { ExtractionResult } from './prompts'
import { matchSkillsToTaxonomy } from './skills'

const MODEL_VERSION = 'claude-haiku-4-5-20251001'
const MAX_RETRIES = 3

export const extractFromText = action({
  args: {
    text: v.string(),
    profileId: v.optional(v.id('profiles')), // Optional: link to profile for context
  },
  handler: async (ctx, { text, profileId }) => {
    // 1. Extract with retry
    const extractedData = await extractWithRetry(text)

    // 2. Match skills to taxonomy
    const taxonomy = await ctx.runQuery(
      internal.extraction.queries.getSkillsTaxonomy,
    )
    const matchedSkills = matchSkillsToTaxonomy(
      extractedData.rawSkills || [],
      taxonomy,
    )

    // 3. Return results (no document to update for text extraction)
    return {
      success: true,
      extractedData: { ...extractedData, skills: matchedSkills },
    }
  },
})

async function extractWithRetry(text: string): Promise<ExtractionResult> {
  const anthropic = new Anthropic()
  let lastError: Error | null = null

  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
    try {
      const response = await anthropic.messages.create({
        model: MODEL_VERSION,
        max_tokens: 4096,
        tools: [extractProfileTool],
        tool_choice: { type: 'tool', name: 'extract_profile_info' },
        system: EXTRACTION_SYSTEM_PROMPT,
        messages: [
          {
            role: 'user',
            content: `Extract the profile information from this resume/CV text:\n\n${text}`,
          },
        ],
      })

      const toolUse = response.content.find(
        (block) => block.type === 'tool_use',
      )
      if (!toolUse || toolUse.type !== 'tool_use') {
        throw new Error('No tool use in Claude response')
      }

      return toolUse.input as ExtractionResult
    } catch (error) {
      lastError = error as Error
      if (attempt < MAX_RETRIES - 1) {
        await new Promise((resolve) =>
          setTimeout(resolve, Math.pow(2, attempt) * 1000),
        )
      }
    }
  }

  throw lastError || new Error('Extraction failed after retries')
}
```

Text extraction differs from PDF:

- Takes raw text string instead of documentId
- No document status to update
- Returns result directly for frontend to handle
- Same extraction logic and skill matching
  </action>
  <verify>Run `bun run lint` - TypeScript should compile</verify>
  <done>extractFromText action processes pasted text through same extraction logic as PDF</done>
  </task>

<task type="auto">
  <name>Task 3: Create extraction mutations and queries</name>
  <files>convex/extraction/mutations.ts, convex/extraction/queries.ts</files>
  <action>
Create two files for supporting operations.

**convex/extraction/mutations.ts:**

```typescript
import { v } from 'convex/values'
import { internalMutation } from '../_generated/server'

// Update document status (used during extraction flow)
export const updateDocumentStatus = internalMutation({
  args: {
    documentId: v.id('uploadedDocuments'),
    status: v.union(
      v.literal('pending_extraction'),
      v.literal('extracting'),
      v.literal('extracted'),
      v.literal('failed'),
    ),
    errorMessage: v.optional(v.string()),
  },
  handler: async (ctx, { documentId, status, errorMessage }) => {
    await ctx.db.patch(documentId, {
      status,
      ...(errorMessage && { errorMessage }),
    })
  },
})

// Save extraction results to document
export const saveExtractionResult = internalMutation({
  args: {
    documentId: v.id('uploadedDocuments'),
    extractedData: v.object({
      name: v.optional(v.string()),
      email: v.optional(v.string()),
      location: v.optional(v.string()),
      education: v.optional(
        v.array(
          v.object({
            institution: v.string(),
            degree: v.optional(v.string()),
            field: v.optional(v.string()),
            startYear: v.optional(v.number()),
            endYear: v.optional(v.number()),
            current: v.optional(v.boolean()),
          }),
        ),
      ),
      workHistory: v.optional(
        v.array(
          v.object({
            organization: v.string(),
            title: v.string(),
            startDate: v.optional(v.string()),
            endDate: v.optional(v.string()),
            description: v.optional(v.string()),
          }),
        ),
      ),
      skills: v.optional(v.array(v.string())),
      rawSkills: v.optional(v.array(v.string())),
    }),
  },
  handler: async (ctx, { documentId, extractedData }) => {
    await ctx.db.patch(documentId, {
      extractedData,
      status: 'extracted' as const,
    })
  },
})
```

**convex/extraction/queries.ts:**

```typescript
import { v } from 'convex/values'
import { internalQuery } from '../_generated/server'

// Get document by ID (internal use for extraction)
export const getDocument = internalQuery({
  args: { documentId: v.id('uploadedDocuments') },
  handler: async (ctx, { documentId }) => {
    return await ctx.db.get(documentId)
  },
})

// Get skills taxonomy for matching
export const getSkillsTaxonomy = internalQuery({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query('skillsTaxonomy').collect()
  },
})

// Get document with extraction status (for frontend polling)
export const getDocumentStatus = internalQuery({
  args: { documentId: v.id('uploadedDocuments') },
  handler: async (ctx, { documentId }) => {
    const doc = await ctx.db.get(documentId)
    if (!doc) return null
    return {
      status: doc.status,
      extractedData: doc.extractedData,
      errorMessage: doc.errorMessage,
    }
  },
})
```

Note: Use internalMutation and internalQuery since these are called by actions, not directly by clients.
</action>
<verify>Run `bun run lint` - all files should compile without errors now that queries exist</verify>
<done>Mutations save extraction results and update status, queries support extraction actions</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bun run lint` passes with no errors
2. `bun run dev:convex` starts successfully
3. All extraction module files exist in convex/extraction/
4. Can test extraction via Convex dashboard:
   - Upload a PDF via test-upload page
   - Note the documentId from success state
   - Call extraction.pdf.extractFromPdf with that documentId
   - Verify document status changes to "extracted" with extractedData populated
</verification>

<success_criteria>

- PDF extraction retrieves file from Convex storage and sends base64 to Claude
- Text extraction processes raw text through same extraction pipeline
- Both actions retry 2-3x with exponential backoff on Claude API failures
- Extraction results are persisted to uploadedDocuments with "extracted" status
- Failed extractions set "failed" status with error message
  </success_criteria>

<output>
After completion, create `.planning/phases/08-llm-extraction-core/08-02-SUMMARY.md`
</output>
