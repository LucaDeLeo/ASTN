---
phase: 08-llm-extraction-core
plan: 03
type: execute
wave: 3
depends_on: ['08-02']
files_modified:
  - src/components/profile/upload/hooks/useExtraction.ts
  - src/components/profile/upload/ExtractionProgress.tsx
  - src/components/profile/upload/ExtractionError.tsx
  - src/components/profile/upload/index.ts
  - src/routes/test-upload.tsx
  - convex/extraction/queries.ts
autonomous: false

must_haves:
  truths:
    - 'User sees progress stages during extraction (Reading document, Extracting info, Matching skills)'
    - 'User sees clear error message when extraction fails'
    - 'User can retry failed extraction'
    - 'User can choose alternative input method (paste text, manual entry) after failure'
    - 'Extraction triggers automatically after successful upload'
  artifacts:
    - path: 'src/components/profile/upload/hooks/useExtraction.ts'
      provides: 'Extraction state management hook'
      exports: ['useExtraction', 'ExtractionState']
    - path: 'src/components/profile/upload/ExtractionProgress.tsx'
      provides: 'Progress indicator with stages'
      exports: ['ExtractionProgress']
    - path: 'src/components/profile/upload/ExtractionError.tsx'
      provides: 'Error UI with retry and fallback options'
      exports: ['ExtractionError']
  key_links:
    - from: 'src/components/profile/upload/hooks/useExtraction.ts'
      to: 'api.extraction.pdf.extractFromPdf'
      via: 'useAction hook'
      pattern: 'useAction.*extractFromPdf'
    - from: 'src/routes/test-upload.tsx'
      to: 'useExtraction'
      via: 'hook integration'
      pattern: 'useExtraction'
---

<objective>
Build the frontend extraction experience with progress feedback, error handling, and fallback options.

Purpose: Give users visibility into extraction progress and graceful recovery from failures.
Output: useExtraction hook, progress component, error UI, integrated into test-upload page.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-llm-extraction-core/08-CONTEXT.md
@.planning/phases/08-llm-extraction-core/08-02-SUMMARY.md
@src/components/profile/upload/hooks/useFileUpload.ts
@src/components/profile/upload/index.ts
@src/routes/test-upload.tsx
@convex/extraction/pdf.ts
@convex/extraction/text.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add public extraction query</name>
  <files>convex/extraction/queries.ts</files>
  <action>
Add a public query for frontend to poll document status (the existing getDocumentStatus is internal).

Add to convex/extraction/queries.ts:

```typescript
import { query } from '../_generated/server'
// ... existing imports

// Public query for frontend to check extraction status
export const getExtractionStatus = query({
  args: { documentId: v.id('uploadedDocuments') },
  handler: async (ctx, { documentId }) => {
    const doc = await ctx.db.get(documentId)
    if (!doc) return null
    return {
      status: doc.status,
      extractedData: doc.extractedData,
      errorMessage: doc.errorMessage,
    }
  },
})
```

This allows frontend to subscribe to extraction status updates via useQuery.
</action>
<verify>Run `bun run lint` - should pass</verify>
<done>Public getExtractionStatus query available for frontend polling</done>
</task>

<task type="auto">
  <name>Task 2: Create useExtraction hook</name>
  <files>src/components/profile/upload/hooks/useExtraction.ts</files>
  <action>
Create hook to manage extraction lifecycle with these states:
- idle: No extraction in progress
- extracting: Extraction running (with stage indicator)
- success: Extraction complete with data
- error: Extraction failed with error message

```typescript
import { useState, useCallback, useEffect } from 'react'
import { useAction, useQuery } from 'convex/react'
import { api } from '../../../../../convex/_generated/api'
import type { Id } from '../../../../../convex/_generated/dataModel'

export type ExtractionStage = 'reading' | 'extracting' | 'matching'

export type ExtractionState =
  | { status: 'idle' }
  | {
      status: 'extracting'
      stage: ExtractionStage
      documentId: Id<'uploadedDocuments'>
    }
  | { status: 'success'; extractedData: ExtractedData }
  | { status: 'error'; error: string; canRetry: boolean }

// Matches the extractedData shape from schema
export interface ExtractedData {
  name?: string
  email?: string
  location?: string
  education?: Array<{
    institution: string
    degree?: string
    field?: string
    startYear?: number
    endYear?: number
    current?: boolean
  }>
  workHistory?: Array<{
    organization: string
    title: string
    startDate?: string
    endDate?: string
    description?: string
  }>
  skills?: string[]
  rawSkills?: string[]
}

export interface UseExtractionReturn {
  state: ExtractionState
  extractFromDocument: (documentId: Id<'uploadedDocuments'>) => Promise<void>
  extractFromText: (text: string) => Promise<void>
  retry: () => void
  reset: () => void
}

export function useExtraction(): UseExtractionReturn {
  const [state, setState] = useState<ExtractionState>({ status: 'idle' })
  const [lastDocumentId, setLastDocumentId] =
    useState<Id<'uploadedDocuments'> | null>(null)
  const [lastText, setLastText] = useState<string | null>(null)

  const extractPdfAction = useAction(api.extraction.pdf.extractFromPdf)
  const extractTextAction = useAction(api.extraction.text.extractFromText)

  // Poll for status updates when extracting
  const documentStatus = useQuery(
    api.extraction.queries.getExtractionStatus,
    state.status === 'extracting' && state.documentId
      ? { documentId: state.documentId }
      : 'skip',
  )

  // Update state based on polling results
  useEffect(() => {
    if (state.status !== 'extracting' || !documentStatus) return

    if (documentStatus.status === 'extracted' && documentStatus.extractedData) {
      setState({
        status: 'success',
        extractedData: documentStatus.extractedData as ExtractedData,
      })
    } else if (documentStatus.status === 'failed') {
      setState({
        status: 'error',
        error: documentStatus.errorMessage || 'Extraction failed',
        canRetry: true,
      })
    }
  }, [documentStatus, state.status])

  const extractFromDocument = useCallback(
    async (documentId: Id<'uploadedDocuments'>) => {
      setLastDocumentId(documentId)
      setLastText(null)

      // Simulate stage progression for UX (actual stages happen server-side)
      setState({ status: 'extracting', stage: 'reading', documentId })

      // Brief delay to show "reading" stage, then update to "extracting"
      setTimeout(() => {
        setState((prev) =>
          prev.status === 'extracting'
            ? { ...prev, stage: 'extracting' }
            : prev,
        )
      }, 500)

      setTimeout(() => {
        setState((prev) =>
          prev.status === 'extracting' ? { ...prev, stage: 'matching' } : prev,
        )
      }, 2000)

      try {
        // Action runs and updates document status
        // Polling above will catch success/failure
        await extractPdfAction({ documentId })
      } catch (error) {
        // Action threw - set error state directly
        setState({
          status: 'error',
          error: error instanceof Error ? error.message : 'Extraction failed',
          canRetry: true,
        })
      }
    },
    [extractPdfAction],
  )

  const extractFromText = useCallback(
    async (text: string) => {
      setLastText(text)
      setLastDocumentId(null)

      setState({
        status: 'extracting',
        stage: 'extracting',
        documentId: '' as Id<'uploadedDocuments'>,
      })

      try {
        const result = await extractTextAction({ text })
        if (result.success && result.extractedData) {
          setState({
            status: 'success',
            extractedData: result.extractedData as ExtractedData,
          })
        } else {
          throw new Error('Extraction returned no data')
        }
      } catch (error) {
        setState({
          status: 'error',
          error: error instanceof Error ? error.message : 'Extraction failed',
          canRetry: true,
        })
      }
    },
    [extractTextAction],
  )

  const retry = useCallback(() => {
    if (lastDocumentId) {
      extractFromDocument(lastDocumentId)
    } else if (lastText) {
      extractFromText(lastText)
    }
  }, [lastDocumentId, lastText, extractFromDocument, extractFromText])

  const reset = useCallback(() => {
    setState({ status: 'idle' })
    setLastDocumentId(null)
    setLastText(null)
  }, [])

  return {
    state,
    extractFromDocument,
    extractFromText,
    retry,
    reset,
  }
}
```

The hook:

- Tracks extraction state with discriminated union
- Simulates stage progression for UX (actual extraction is ~5-10s)
- Polls document status during PDF extraction
- Handles both PDF and text extraction
- Provides retry that remembers last input
  </action>
  <verify>Run `bun run lint` - should pass</verify>
  <done>useExtraction hook manages extraction lifecycle with progress stages and error handling</done>
  </task>

<task type="auto">
  <name>Task 3: Create extraction UI components</name>
  <files>src/components/profile/upload/ExtractionProgress.tsx, src/components/profile/upload/ExtractionError.tsx, src/components/profile/upload/index.ts</files>
  <action>
Create two UI components for extraction feedback.

**ExtractionProgress.tsx:**

```typescript
import { Loader2, FileText, Brain, Tags } from "lucide-react";
import type { ExtractionStage } from "./hooks/useExtraction";

interface ExtractionProgressProps {
  stage: ExtractionStage;
  fileName?: string;
}

const stages: Record<ExtractionStage, { label: string; icon: typeof FileText }> = {
  reading: { label: "Reading document...", icon: FileText },
  extracting: { label: "Extracting information...", icon: Brain },
  matching: { label: "Matching skills...", icon: Tags },
};

export function ExtractionProgress({ stage, fileName }: ExtractionProgressProps) {
  const currentStage = stages[stage];
  const Icon = currentStage.icon;

  return (
    <div className="rounded-lg border bg-card p-6 text-center space-y-4">
      <div className="flex justify-center">
        <div className="relative">
          <Icon className="h-12 w-12 text-primary/30" />
          <Loader2 className="absolute inset-0 h-12 w-12 text-primary animate-spin" />
        </div>
      </div>
      <div className="space-y-1">
        <p className="font-medium text-foreground">{currentStage.label}</p>
        {fileName && (
          <p className="text-sm text-muted-foreground">{fileName}</p>
        )}
      </div>
      <div className="flex justify-center gap-2">
        {(["reading", "extracting", "matching"] as const).map((s) => (
          <div
            key={s}
            className={`h-2 w-2 rounded-full transition-colors ${
              s === stage
                ? "bg-primary"
                : stages[s] && Object.keys(stages).indexOf(s) < Object.keys(stages).indexOf(stage)
                ? "bg-primary/50"
                : "bg-muted"
            }`}
          />
        ))}
      </div>
    </div>
  );
}
```

**ExtractionError.tsx:**

```typescript
import { AlertCircle, RotateCcw, Type, Edit3 } from "lucide-react";
import { Button } from "~/components/ui/button";

interface ExtractionErrorProps {
  error: string;
  onRetry: () => void;
  onPasteText: () => void;
  onManualEntry: () => void;
  canRetry: boolean;
}

export function ExtractionError({
  error,
  onRetry,
  onPasteText,
  onManualEntry,
  canRetry,
}: ExtractionErrorProps) {
  return (
    <div className="rounded-lg border border-destructive/50 bg-destructive/10 p-6 space-y-4">
      <div className="flex items-start gap-3">
        <AlertCircle className="h-5 w-5 text-destructive shrink-0 mt-0.5" />
        <div className="space-y-1">
          <p className="font-medium text-destructive">Extraction failed</p>
          <p className="text-sm text-muted-foreground">{error}</p>
        </div>
      </div>
      <div className="flex flex-col sm:flex-row gap-2">
        {canRetry && (
          <Button onClick={onRetry} variant="outline" className="flex-1">
            <RotateCcw className="mr-2 h-4 w-4" />
            Try again
          </Button>
        )}
        <Button onClick={onPasteText} variant="outline" className="flex-1">
          <Type className="mr-2 h-4 w-4" />
          Paste text instead
        </Button>
        <Button onClick={onManualEntry} variant="outline" className="flex-1">
          <Edit3 className="mr-2 h-4 w-4" />
          Enter manually
        </Button>
      </div>
    </div>
  );
}
```

**Update index.ts** to export new components:

```typescript
// Add to existing exports
export { ExtractionProgress } from './ExtractionProgress'
export { ExtractionError } from './ExtractionError'
export { useExtraction } from './hooks/useExtraction'
export type {
  ExtractionState,
  ExtractedData,
  ExtractionStage,
} from './hooks/useExtraction'
```

  </action>
  <verify>Run `bun run lint` - should pass. Components should compile without errors.</verify>
  <done>ExtractionProgress shows stage indicators, ExtractionError provides retry and fallback options</done>
</task>

<task type="auto">
  <name>Task 4: Integrate extraction into test-upload page</name>
  <files>src/routes/test-upload.tsx</files>
  <action>
Update test-upload.tsx to demonstrate the full extraction flow.

After successful upload, automatically trigger extraction. Show progress during extraction. Display results or error UI when complete.

Key changes:

1. Import and use useExtraction hook
2. Trigger extractFromDocument when upload succeeds
3. Show ExtractionProgress during extraction
4. Show ExtractionError on failure with retry/fallback handlers
5. Show extracted data preview on success
6. Wire text paste to extractFromText

```typescript
import { createFileRoute } from "@tanstack/react-router";
import { useState, useEffect } from "react";
import {
  DocumentUpload,
  FilePreview,
  TextPasteZone,
  UploadProgress,
  ExtractionProgress,
  ExtractionError,
  useFileUpload,
  useExtraction,
} from "~/components/profile/upload";

export const Route = createFileRoute("/test-upload")({
  component: TestUploadPage,
});

function TestUploadPage() {
  const { state: uploadState, selectFile, clearFile, upload, retry: retryUpload } = useFileUpload();
  const { state: extractionState, extractFromDocument, extractFromText, retry: retryExtraction, reset: resetExtraction } = useExtraction();
  const [showTextPaste, setShowTextPaste] = useState(false);

  // Auto-trigger extraction when upload succeeds
  useEffect(() => {
    if (uploadState.status === "success" && extractionState.status === "idle") {
      extractFromDocument(uploadState.documentId);
    }
  }, [uploadState, extractionState.status, extractFromDocument]);

  const handleTextSubmit = async (text: string) => {
    setShowTextPaste(false);
    await extractFromText(text);
  };

  const handleStartOver = () => {
    clearFile();
    resetExtraction();
    setShowTextPaste(false);
  };

  const handlePasteTextFallback = () => {
    resetExtraction();
    clearFile();
    setShowTextPaste(true);
  };

  const handleManualEntry = () => {
    // In real app, would navigate to profile form
    alert("Would navigate to manual profile entry");
  };

  return (
    <div className="container mx-auto max-w-2xl p-8 space-y-8">
      <h1 className="text-2xl font-bold">Upload Test Page</h1>
      <p className="text-muted-foreground">
        Test the file upload and extraction flow.
      </p>

      {/* Debug state display */}
      <details className="rounded-lg bg-muted p-4">
        <summary className="font-semibold cursor-pointer">Debug State</summary>
        <div className="mt-2 space-y-2 text-sm">
          <p><strong>Upload:</strong> {uploadState.status}</p>
          <p><strong>Extraction:</strong> {extractionState.status}</p>
        </div>
      </details>

      {/* Initial upload state */}
      {uploadState.status === "idle" && extractionState.status === "idle" && !showTextPaste && (
        <div className="space-y-4">
          <DocumentUpload onFileSelect={selectFile} />
          <div className="flex justify-center">
            <TextPasteZone onTextSubmit={handleTextSubmit} />
          </div>
        </div>
      )}

      {/* Text paste expanded */}
      {showTextPaste && extractionState.status === "idle" && (
        <div className="space-y-4">
          <TextPasteZone onTextSubmit={handleTextSubmit} defaultExpanded />
          <button onClick={() => setShowTextPaste(false)} className="text-sm text-muted-foreground hover:text-foreground">
            Cancel and upload file instead
          </button>
        </div>
      )}

      {/* File selected, ready to upload */}
      {uploadState.status === "selected" && (
        <div className="space-y-4">
          <FilePreview file={uploadState.file} onRemove={clearFile} />
          <button
            onClick={upload}
            className="w-full rounded-lg bg-primary px-4 py-2 text-primary-foreground hover:bg-primary/90"
          >
            Upload and Extract
          </button>
        </div>
      )}

      {/* Uploading */}
      {uploadState.status === "uploading" && (
        <div className="space-y-4">
          <FilePreview file={uploadState.file} onRemove={() => {}} disabled />
          <UploadProgress
            progress={uploadState.progress}
            status="uploading"
            fileName={uploadState.file.name}
          />
        </div>
      )}

      {/* Upload error */}
      {uploadState.status === "error" && extractionState.status === "idle" && (
        <div className="space-y-4">
          <DocumentUpload
            onFileSelect={selectFile}
            error={uploadState.error}
            onErrorDismiss={clearFile}
          />
          <div className="flex gap-2">
            <button onClick={retryUpload} className="rounded bg-primary px-4 py-2 text-primary-foreground">
              Retry Upload
            </button>
            <button onClick={handlePasteTextFallback} className="rounded bg-muted px-4 py-2">
              Paste text instead
            </button>
          </div>
        </div>
      )}

      {/* Extraction in progress */}
      {extractionState.status === "extracting" && (
        <ExtractionProgress
          stage={extractionState.stage}
          fileName={uploadState.status === "success" ? uploadState.file.name : undefined}
        />
      )}

      {/* Extraction error */}
      {extractionState.status === "error" && (
        <ExtractionError
          error={extractionState.error}
          onRetry={retryExtraction}
          onPasteText={handlePasteTextFallback}
          onManualEntry={handleManualEntry}
          canRetry={extractionState.canRetry}
        />
      )}

      {/* Extraction success - show preview */}
      {extractionState.status === "success" && (
        <div className="rounded-lg border border-green-500 bg-green-50 p-6 space-y-4">
          <h2 className="font-semibold text-green-700">Extraction Complete!</h2>
          <div className="space-y-3 text-sm">
            {extractionState.extractedData.name && (
              <p><strong>Name:</strong> {extractionState.extractedData.name}</p>
            )}
            {extractionState.extractedData.email && (
              <p><strong>Email:</strong> {extractionState.extractedData.email}</p>
            )}
            {extractionState.extractedData.location && (
              <p><strong>Location:</strong> {extractionState.extractedData.location}</p>
            )}
            {extractionState.extractedData.education && extractionState.extractedData.education.length > 0 && (
              <div>
                <strong>Education:</strong>
                <ul className="list-disc list-inside ml-2">
                  {extractionState.extractedData.education.map((edu, i) => (
                    <li key={i}>{edu.degree} at {edu.institution}</li>
                  ))}
                </ul>
              </div>
            )}
            {extractionState.extractedData.workHistory && extractionState.extractedData.workHistory.length > 0 && (
              <div>
                <strong>Work History:</strong>
                <ul className="list-disc list-inside ml-2">
                  {extractionState.extractedData.workHistory.map((job, i) => (
                    <li key={i}>{job.title} at {job.organization}</li>
                  ))}
                </ul>
              </div>
            )}
            {extractionState.extractedData.skills && extractionState.extractedData.skills.length > 0 && (
              <div>
                <strong>Matched Skills:</strong>
                <div className="flex flex-wrap gap-1 mt-1">
                  {extractionState.extractedData.skills.map((skill) => (
                    <span key={skill} className="rounded bg-primary/10 px-2 py-0.5 text-xs text-primary">
                      {skill}
                    </span>
                  ))}
                </div>
              </div>
            )}
          </div>
          <button onClick={handleStartOver} className="rounded bg-green-600 px-4 py-2 text-white hover:bg-green-700">
            Start Over
          </button>
        </div>
      )}
    </div>
  );
}
```

Note: Add `defaultExpanded` prop to TextPasteZone if not already present (optional enhancement).
</action>
<verify>Run `bun run dev` and visit /test-upload. Verify page renders without errors.</verify>
<done>Test page demonstrates full upload -> extraction flow with progress and error handling</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete extraction pipeline: PDF/text extraction via Claude Haiku 4.5 with progress feedback and error handling</what-built>
  <how-to-verify>
1. Start dev server: `bun run dev`
2. Navigate to http://localhost:5173/test-upload
3. Upload a real PDF resume:
   - Drag-drop a PDF or click to select
   - Watch progress stages: "Reading document..." -> "Extracting info..." -> "Matching skills..."
   - Verify extraction completes within ~5-10 seconds
   - Confirm extracted data matches the resume content (name, education, work history, skills)
4. Test text extraction:
   - Click "Start Over" if needed
   - Click "Or paste your resume text" to expand text area
   - Paste a resume text block
   - Verify extraction produces similar structured output
5. Test error handling (optional - requires triggering a failure):
   - Try uploading a very small/corrupted PDF
   - Verify error UI appears with retry and fallback options
  </how-to-verify>
  <resume-signal>Type "approved" if extraction works correctly, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bun run lint` passes
2. `bun run dev` starts successfully
3. Upload flow triggers extraction automatically
4. Progress stages display correctly during extraction
5. Extracted data displays in success state
6. Error UI provides retry and fallback options
</verification>

<success_criteria>

- User sees progress stages during extraction (3 stages shown)
- User sees clear error message when extraction fails
- User can retry failed extraction
- User can choose paste text or manual entry after failure
- Extraction triggers automatically after successful PDF upload
- Extracted data displays with name, education, work history, matched skills
  </success_criteria>

<output>
After completion, create `.planning/phases/08-llm-extraction-core/08-03-SUMMARY.md`
</output>
