---
phase: 13-event-notifications
plan: 02
type: execute
wave: 2
depends_on: ['13-01']
files_modified:
  - convex/emails/templates.tsx
  - convex/emails/batchActions.ts
  - convex/emails/send.ts
  - convex/crons.ts
  - convex/notifications/realtime.ts
autonomous: true

must_haves:
  truths:
    - "User with 'daily' frequency sees digest email in inbox around 9 AM their local time"
    - "User with 'weekly' frequency sees digest email in inbox Sunday evening"
    - "User with 'all' frequency sees new event notification in app notification bell immediately"
    - 'User opening digest email sees events grouped by organization name'
    - 'User can click RSVP link in digest email to navigate to event page'
  artifacts:
    - path: 'convex/emails/templates.tsx'
      provides: 'EventDigestEmail component'
      contains: 'EventDigestEmail'
    - path: 'convex/emails/batchActions.ts'
      provides: 'processDailyEventDigestBatch, processWeeklyEventDigestBatch actions'
      contains: 'processDailyEventDigestBatch'
    - path: 'convex/crons.ts'
      provides: 'Daily and weekly event digest cron jobs'
      contains: 'send-daily-event-digest'
  key_links:
    - from: 'convex/crons.ts'
      to: 'convex/emails/batchActions.ts'
      via: 'crons.hourly/crons.weekly calls'
      pattern: 'processDailyEventDigestBatch'
    - from: 'convex/emails/batchActions.ts'
      to: 'convex/emails/templates.tsx'
      via: 'renderEventDigest function'
      pattern: 'renderEventDigest'
    - from: 'convex/events/mutations.ts'
      to: 'convex/notifications/realtime.ts'
      via: 'notifyAllFrequencyUsers call after event insert in upsertEvents'
      pattern: 'notifyAllFrequencyUsers'
---

<objective>
Implement event digest emails with timezone-aware delivery.

Purpose: Users who prefer digest notifications (daily or weekly) should receive batched event emails at appropriate times. This prevents notification fatigue while keeping users informed.
Output: Email templates and cron-triggered batch processing for event digests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-event-notifications/13-CONTEXT.md
@.planning/phases/13-event-notifications/13-RESEARCH.md
@.planning/phases/13-event-notifications/13-01-SUMMARY.md

# Existing email patterns

@convex/emails/templates.tsx
@convex/emails/batchActions.ts
@convex/emails/send.ts
@convex/crons.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create event digest email template</name>
  <files>convex/emails/templates.tsx</files>
  <action>
Add EventDigestEmail component and renderEventDigest function to templates.tsx, following the existing pattern.

**Interface:**

```typescript
interface EventDigestProps {
  userName: string
  frequency: 'daily' | 'weekly'
  events: Array<{
    title: string
    orgName: string
    startAt: number
    location?: string
    isVirtual: boolean
    url: string
    description?: string
  }>
}
```

**Component structure:**

- Header with ASTN logo
- Greeting: "Hi {userName},"
- Intro: "Here are upcoming events from your organizations:" (for daily) or "Here's your weekly event roundup:" (for weekly)
- Events grouped by org name (per Phase 12 pattern from CONTEXT.md)
- Max 5 events per org with "+X more events" overflow indicator
- Each event shows:
  - Title (font-medium)
  - Date formatted as "EEE, MMM d 'at' h:mm a" using date-fns format
  - Location or "Online" for virtual events
  - Description snippet (first 100 chars if present)
  - "View event & RSVP on lu.ma" button linking to event.url
- Footer with "Manage notification preferences" link to /settings
- Use existing CORAL brand color and styling patterns

**Render function:**

```typescript
export async function renderEventDigest(props: EventDigestProps): Promise<string> {
  return await render(<EventDigestEmail {...props} />);
}
```

Import format from date-fns at the top of the file.
</action>
<verify>Run `bun run lint` - no TypeScript errors in templates.tsx</verify>
<done>EventDigestEmail component renders grouped events with proper formatting and RSVP links</done>
</task>

<task type="auto">
  <name>Task 2: Add digest batch processing actions</name>
  <files>convex/emails/batchActions.ts, convex/emails/send.ts</files>
  <action>
**In convex/emails/send.ts:**

1. Add `sendEventDigest` mutation (like sendMatchAlert/sendWeeklyDigest):

```typescript
export const sendEventDigest = internalMutation({
  args: {
    to: v.string(),
    subject: v.string(),
    html: v.string(),
  },
  handler: async (ctx, { to, subject, html }) => {
    await resend.sendEmail(ctx, {
      from: FROM_ADDRESS,
      to,
      subject,
      html,
    })
  },
})
```

2. Add `getUsersForDailyEventDigestBatch` query:

```typescript
export const getUsersForDailyEventDigestBatch = internalQuery({
  args: { targetLocalHour: v.number() },
  handler: async (ctx, { targetLocalHour }) => {
    const profiles = await ctx.db.query('profiles').collect()
    const now = new Date()
    const usersToNotify: Array<{
      userId: string
      email: string
      timezone: string
      profileId: Id<'profiles'>
      userName: string
      mutedOrgIds: Array<Id<'organizations'>>
    }> = []

    for (const profile of profiles) {
      // Check for daily event digest
      if (profile.eventNotificationPreferences?.frequency !== 'daily') continue

      const timezone = profile.notificationPreferences?.timezone || 'UTC'
      const userLocalTime = toZonedTime(now, timezone)
      const userLocalHour = userLocalTime.getHours()

      if (userLocalHour === targetLocalHour) {
        const user = await ctx.db
          .query('users')
          .filter((q) => q.eq(q.field('_id'), profile.userId))
          .first()

        if (user?.email) {
          usersToNotify.push({
            userId: profile.userId,
            email: user.email,
            timezone,
            profileId: profile._id,
            userName: profile.name || 'there',
            mutedOrgIds:
              profile.eventNotificationPreferences?.mutedOrgIds || [],
          })
        }
      }
    }
    return usersToNotify
  },
})
```

3. Add `getUsersForWeeklyEventDigestBatch` query (similar but checks for "weekly" frequency, no timezone filtering since weekly runs once).

4. Add `getUpcomingEventsForUser` query:

```typescript
export const getUpcomingEventsForUser = internalQuery({
  args: {
    userId: v.string(),
    mutedOrgIds: v.array(v.id('organizations')),
    since: v.number(),
  },
  handler: async (ctx, { userId, mutedOrgIds, since }) => {
    // Get user's org memberships
    const memberships = await ctx.db
      .query('orgMemberships')
      .withIndex('by_user', (q) => q.eq('userId', userId))
      .collect()

    const orgIds = memberships
      .map((m) => m.orgId)
      .filter((id) => !mutedOrgIds.includes(id))

    // Get upcoming events from user's (non-muted) orgs
    const events: Array<Doc<'events'> & { orgName: string }> = []
    for (const orgId of orgIds) {
      const org = await ctx.db.get(orgId)
      if (!org) continue

      const orgEvents = await ctx.db
        .query('events')
        .withIndex('by_org_start', (q) =>
          q.eq('orgId', orgId).gt('startAt', since),
        )
        .take(10)

      events.push(...orgEvents.map((e) => ({ ...e, orgName: org.name })))
    }

    // Sort by start time and limit
    return events.sort((a, b) => a.startAt - b.startAt).slice(0, 20)
  },
})
```

**In convex/emails/batchActions.ts:**

Add `processDailyEventDigestBatch` action:

```typescript
const DAILY_DIGEST_TARGET_HOUR = 9 // 9 AM local time

export const processDailyEventDigestBatch = internalAction({
  args: {},
  handler: async (ctx) => {
    console.log('Starting daily event digest batch processing...')

    const users = await ctx.runQuery(
      internal.emails.send.getUsersForDailyEventDigestBatch,
      { targetLocalHour: DAILY_DIGEST_TARGET_HOUR },
    )

    if (users.length === 0) {
      console.log('No users in the 9 AM timezone bucket for daily digest')
      return { processed: 0, emailsSent: 0 }
    }

    let emailsSent = 0
    const now = Date.now()

    for (let i = 0; i < users.length; i += BATCH_SIZE) {
      const batch = users.slice(i, i + BATCH_SIZE)

      for (const user of batch) {
        const events = await ctx.runQuery(
          internal.emails.send.getUpcomingEventsForUser,
          { userId: user.userId, mutedOrgIds: user.mutedOrgIds, since: now },
        )

        if (events.length === 0) continue

        const emailContent = await renderEventDigest({
          userName: user.userName,
          frequency: 'daily',
          events: events.map((e) => ({
            title: e.title,
            orgName: e.orgName,
            startAt: e.startAt,
            location: e.location,
            isVirtual: e.isVirtual,
            url: e.url,
            description: e.description,
          })),
        })

        await ctx.runMutation(internal.emails.send.sendEventDigest, {
          to: user.email,
          subject: 'Your daily event digest from ASTN',
          html: emailContent,
        })

        emailsSent++
      }
    }

    console.log(`Daily event digest batch complete: ${emailsSent} emails sent`)
    return { processed: users.length, emailsSent }
  },
})
```

Add similar `processWeeklyEventDigestBatch` action (uses "weekly" frequency users, subject "Your weekly event digest from ASTN").

Import renderEventDigest from templates.tsx at top of file.
</action>
<verify>Run `bun run lint` - no TypeScript errors in batchActions.ts and send.ts</verify>
<done>Batch processing actions query users by digest preference and send formatted event digest emails</done>
</task>

<task type="auto">
  <name>Task 3: Add digest cron jobs</name>
  <files>convex/crons.ts</files>
  <action>
Add two new cron jobs after the existing ones:

```typescript
// Run hourly to process daily event digest for each timezone's 9 AM
// Offset from match alerts at :00 to avoid collision
crons.hourly(
  'send-daily-event-digest',
  { minuteUTC: 30 },
  internal.emails.batchActions.processDailyEventDigestBatch,
  {},
)

// Run weekly on Sunday evening UTC (same time as weekly opportunity digest)
// Users who have both enabled will get both in same window
crons.weekly(
  'send-weekly-event-digest',
  { dayOfWeek: 'sunday', hourUTC: 22, minuteUTC: 30 },
  internal.emails.batchActions.processWeeklyEventDigestBatch,
  {},
)
```

The daily digest runs hourly at :30 to check which timezones hit 9 AM. This is offset from match alerts at :00.

The weekly digest runs Sunday 22:30 UTC, 30 minutes after the opportunity weekly digest.
</action>
<verify>

1. Run `bun run lint` - no errors
2. Run `bun run dev:convex` and check crons are registered in Convex dashboard
   </verify>
   <done>Cron jobs schedule daily (9 AM local) and weekly (Sunday evening) event digest processing</done>
   </task>

<task type="auto">
  <name>Task 4: Add real-time notifications for "all" frequency users</name>
  <files>convex/notifications/realtime.ts, convex/events/mutations.ts</files>
  <action>
**Create convex/notifications/realtime.ts:**

This module handles immediate notifications for users with "all" frequency when new events are created.

```typescript
import { v } from 'convex/values'
import { internalMutation, internalQuery } from '../_generated/server'
import type { Id } from '../_generated/dataModel'

// Rate limit: max 5 event notifications per hour per user
const RATE_LIMIT_WINDOW = 60 * 60 * 1000 // 1 hour
const RATE_LIMIT_MAX = 5

export const getUsersForAllFrequency = internalQuery({
  args: { orgId: v.id('organizations') },
  handler: async (ctx, { orgId }) => {
    // Get org members
    const memberships = await ctx.db
      .query('orgMemberships')
      .withIndex('by_org', (q) => q.eq('orgId', orgId))
      .collect()

    const usersToNotify: Array<{
      userId: string
      profileId: Id<'profiles'>
    }> = []

    for (const membership of memberships) {
      const profile = await ctx.db
        .query('profiles')
        .withIndex('by_user', (q) => q.eq('userId', membership.userId))
        .first()

      if (!profile) continue

      // Check for "all" frequency
      if (profile.eventNotificationPreferences?.frequency !== 'all') continue

      // Check if org is muted
      if (profile.eventNotificationPreferences?.mutedOrgIds?.includes(orgId))
        continue

      usersToNotify.push({
        userId: membership.userId,
        profileId: profile._id,
      })
    }

    return usersToNotify
  },
})

export const notifyAllFrequencyUsers = internalMutation({
  args: {
    eventId: v.id('events'),
    orgId: v.id('organizations'),
  },
  handler: async (ctx, { eventId, orgId }) => {
    const event = await ctx.db.get(eventId)
    if (!event) return { notified: 0, rateLimited: 0 }

    const org = await ctx.db.get(orgId)
    if (!org) return { notified: 0, rateLimited: 0 }

    const users = await ctx.runQuery(
      internal.notifications.realtime.getUsersForAllFrequency,
      { orgId },
    )

    const now = Date.now()
    let notified = 0
    let rateLimited = 0

    for (const user of users) {
      // Check rate limit: count recent notifications for this user
      const recentNotifications = await ctx.db
        .query('notifications')
        .withIndex('by_user', (q) => q.eq('userId', user.userId))
        .filter((q) =>
          q.and(
            q.eq(q.field('type'), 'event_new'),
            q.gt(q.field('createdAt'), now - RATE_LIMIT_WINDOW),
          ),
        )
        .collect()

      if (recentNotifications.length >= RATE_LIMIT_MAX) {
        rateLimited++
        continue // Skip - user hit rate limit
      }

      // Create in-app notification
      await ctx.db.insert('notifications', {
        userId: user.userId,
        type: 'event_new',
        eventId,
        orgId,
        title: `New event: ${event.title}`,
        body: org.name,
        actionUrl: event.url,
        read: false,
        createdAt: now,
      })

      notified++
    }

    console.log(
      `Real-time event notification: ${notified} notified, ${rateLimited} rate-limited`,
    )
    return { notified, rateLimited }
  },
})
```

**Modify convex/events/mutations.ts - upsertEvents function (around line 43-48):**

The upsertEvents function currently has a simple insert for new events. Modify the "Create new event" block to capture the new event ID and schedule real-time notification:

1. Add import at top of file:

```typescript
import { internal } from '../_generated/api'
```

2. Replace the new event insert block (currently lines 43-48):

```typescript
      } else {
        // Create new event
        const newEventId = await ctx.db.insert("events", {
          ...event,
          orgId,
          syncedAt: now,
        });

        // Notify users with "all" frequency preference
        await ctx.scheduler.runAfter(
          0,
          internal.notifications.realtime.notifyAllFrequencyUsers,
          { eventId: newEventId, orgId }
        );
      }
```

This uses `scheduler.runAfter(0, ...)` to fire immediately but asynchronously, avoiding transaction timeout issues.

Note: Only triggers for genuinely NEW events (the else branch), not updates to existing events.
</action>
<verify>

1. Run `bun run lint` - no TypeScript errors
2. Verify convex/events/mutations.ts imports internal and calls notifyAllFrequencyUsers in the new event branch
   </verify>
   <done>Users with "all" frequency receive in-app notifications when new events are created, with rate limiting (max 5/hour)</done>
   </task>

</tasks>

<verification>
- [ ] EventDigestEmail renders with proper grouping by org
- [ ] Daily digest batch processes users with "daily" frequency at 9 AM local
- [ ] Weekly digest batch processes users with "weekly" frequency
- [ ] "All" frequency users receive in-app notifications on new events
- [ ] Rate limiting prevents more than 5 notifications per hour per user
- [ ] Emails filter out muted orgs
- [ ] Cron jobs registered and scheduled correctly
- [ ] No TypeScript errors
</verification>

<success_criteria>

1. EventDigestEmail template renders grouped events with RSVP links
2. Daily digest cron runs hourly at :30, targeting 9 AM local time
3. Weekly digest cron runs Sunday 22:30 UTC
4. Users with "all" frequency receive in-app notifications when events are created
5. Users with "none" frequency receive no emails
6. Muted orgs are excluded from digest and real-time notifications
7. Rate limiting caps "all" frequency at 5 notifications per hour
8. `bun run lint` passes
   </success_criteria>

<output>
After completion, create `.planning/phases/13-event-notifications/13-02-SUMMARY.md`
</output>
