---
phase: 13-event-notifications
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - convex/notifications/mutations.ts
  - convex/notifications/queries.ts
  - convex/notifications/scheduler.ts
  - src/components/notifications/NotificationBell.tsx
  - src/components/notifications/NotificationList.tsx
  - src/routes/__root.tsx
autonomous: true

must_haves:
  truths:
    - "User sees bell icon with unread count badge in navigation"
    - "User can view recent notifications in dropdown"
    - "User can mark notifications as read"
    - "User receives reminder notification before events they've viewed"
    - "Reminders fire at user-configured timings (1 week, 1 day, 1 hour before)"
  artifacts:
    - path: "convex/notifications/queries.ts"
      provides: "getRecentNotifications, getUnreadCount queries"
      exports: ["getRecentNotifications", "getUnreadCount"]
    - path: "convex/notifications/mutations.ts"
      provides: "createNotification, markAsRead, recordEventView mutations"
      exports: ["createNotification", "markAsRead", "recordEventView"]
    - path: "convex/notifications/scheduler.ts"
      provides: "scheduleRemindersForViewInternal, cancelEventReminders, sendReminder functions"
      exports: ["scheduleRemindersForViewInternal", "sendReminder"]
    - path: "src/components/notifications/NotificationBell.tsx"
      provides: "Bell icon with unread badge and dropdown"
      min_lines: 50
  key_links:
    - from: "src/components/notifications/NotificationBell.tsx"
      to: "convex/notifications/queries.ts"
      via: "useQuery for unread count and recent notifications"
      pattern: "getUnreadCount"
    - from: "convex/notifications/mutations.ts"
      to: "convex/notifications/scheduler.ts"
      via: "recordEventView calls scheduleRemindersForViewInternal via scheduler.runAfter"
      pattern: "scheduler.runAfter.*scheduleRemindersForViewInternal"
    - from: "convex/notifications/scheduler.ts"
      to: "convex/notifications/mutations.ts"
      via: "ctx.scheduler.runAt for reminders"
      pattern: "scheduler.runAt"
---

<objective>
Implement in-app notification center and event reminder scheduling.

Purpose: Users need to see notifications in the app (not just email) and receive timely reminders before events they're interested in. The bell icon provides always-visible access to recent notifications.
Output: Notification bell component in navigation + reminder scheduling system.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-event-notifications/13-CONTEXT.md
@.planning/phases/13-event-notifications/13-RESEARCH.md
@.planning/phases/13-event-notifications/13-01-SUMMARY.md

# Existing patterns
@convex/schema.ts
@src/routes/__root.tsx
@src/components/ui/popover.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notification queries and mutations</name>
  <files>convex/notifications/queries.ts, convex/notifications/mutations.ts</files>
  <action>
Create the convex/notifications/ directory with two files.

**convex/notifications/queries.ts:**
```typescript
import { v } from "convex/values";
import { query } from "../_generated/server";
import { getAuthUserId } from "@convex-dev/auth/server";

export const getUnreadCount = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) return 0;

    const unread = await ctx.db
      .query("notifications")
      .withIndex("by_user_read", (q) => q.eq("userId", userId).eq("read", false))
      .collect();

    return unread.length;
  },
});

export const getRecentNotifications = query({
  args: { limit: v.optional(v.number()) },
  handler: async (ctx, { limit = 10 }) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) return [];

    const notifications = await ctx.db
      .query("notifications")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .order("desc")
      .take(limit);

    // Enrich with event/org data
    return Promise.all(
      notifications.map(async (n) => {
        let eventTitle: string | undefined;
        let orgName: string | undefined;

        if (n.eventId) {
          const event = await ctx.db.get(n.eventId);
          eventTitle = event?.title;
        }
        if (n.orgId) {
          const org = await ctx.db.get(n.orgId);
          orgName = org?.name;
        }

        return { ...n, eventTitle, orgName };
      })
    );
  },
});
```

**convex/notifications/mutations.ts:**
```typescript
import { v } from "convex/values";
import { mutation, internalMutation } from "../_generated/server";
import { internal } from "../_generated/api";
import { getAuthUserId } from "@convex-dev/auth/server";

export const markAsRead = mutation({
  args: { notificationId: v.id("notifications") },
  handler: async (ctx, { notificationId }) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const notification = await ctx.db.get(notificationId);
    if (!notification || notification.userId !== userId) {
      throw new Error("Notification not found");
    }

    await ctx.db.patch(notificationId, { read: true });
  },
});

export const markAllAsRead = mutation({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const unread = await ctx.db
      .query("notifications")
      .withIndex("by_user_read", (q) => q.eq("userId", userId).eq("read", false))
      .collect();

    for (const n of unread) {
      await ctx.db.patch(n._id, { read: true });
    }
  },
});

// Internal mutation for creating notifications (called by scheduler)
export const createNotification = internalMutation({
  args: {
    userId: v.string(),
    type: v.union(
      v.literal("event_new"),
      v.literal("event_reminder"),
      v.literal("event_updated")
    ),
    eventId: v.optional(v.id("events")),
    orgId: v.optional(v.id("organizations")),
    title: v.string(),
    body: v.string(),
    actionUrl: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    await ctx.db.insert("notifications", {
      ...args,
      read: false,
      createdAt: Date.now(),
    });
  },
});

// Record event view for reminder audience
export const recordEventView = mutation({
  args: { eventId: v.id("events") },
  handler: async (ctx, { eventId }) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) return;

    // Check if already viewed
    const existing = await ctx.db
      .query("eventViews")
      .withIndex("by_user_event", (q) => q.eq("userId", userId).eq("eventId", eventId))
      .first();

    if (existing) return; // Already tracked

    await ctx.db.insert("eventViews", {
      userId,
      eventId,
      viewedAt: Date.now(),
    });

    // Schedule reminders for this user based on their preferences
    // Use scheduler.runAfter to invoke the scheduling mutation
    await ctx.scheduler.runAfter(
      0, // Run immediately but asynchronously
      internal.notifications.scheduler.scheduleRemindersForViewInternal,
      { eventId, userId }
    );
  },
});
```
  </action>
  <verify>Run `bun run lint` - no TypeScript errors in notifications/ directory</verify>
  <done>Notification queries return user's notifications with unread count; mutations handle read status and event view tracking</done>
</task>

<task type="auto">
  <name>Task 2: Create notification bell component</name>
  <files>src/components/notifications/NotificationBell.tsx, src/components/notifications/NotificationList.tsx</files>
  <action>
Create src/components/notifications/ directory.

**src/components/notifications/NotificationBell.tsx:**
```typescript
import { Bell } from "lucide-react";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { Button } from "~/components/ui/button";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "~/components/ui/popover";
import { NotificationList } from "./NotificationList";

export function NotificationBell() {
  const unreadCount = useQuery(api.notifications.queries.getUnreadCount);
  const notifications = useQuery(api.notifications.queries.getRecentNotifications, { limit: 10 });
  const markAllAsRead = useMutation(api.notifications.mutations.markAllAsRead);

  // Don't render for unauthenticated users
  if (unreadCount === undefined) return null;

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button variant="ghost" size="icon" className="relative">
          <Bell className="size-5" />
          {unreadCount > 0 && (
            <span className="absolute -top-1 -right-1 size-5 rounded-full bg-primary text-xs text-primary-foreground flex items-center justify-center font-medium">
              {unreadCount > 9 ? "9+" : unreadCount}
            </span>
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-80 p-0" align="end">
        <div className="flex items-center justify-between px-4 py-3 border-b">
          <h3 className="font-semibold text-sm">Notifications</h3>
          {unreadCount > 0 && (
            <Button
              variant="ghost"
              size="sm"
              className="text-xs h-auto py-1"
              onClick={() => markAllAsRead()}
            >
              Mark all read
            </Button>
          )}
        </div>
        <NotificationList notifications={notifications || []} />
      </PopoverContent>
    </Popover>
  );
}
```

**src/components/notifications/NotificationList.tsx:**
```typescript
import { formatDistanceToNow } from "date-fns";
import { Calendar, Bell, RefreshCw } from "lucide-react";
import { useMutation } from "convex/react";
import { api } from "../../../convex/_generated/api";
import type { Id } from "../../../convex/_generated/dataModel";
import { cn } from "~/lib/utils";

interface Notification {
  _id: Id<"notifications">;
  type: "event_new" | "event_reminder" | "event_updated";
  title: string;
  body: string;
  actionUrl?: string;
  read: boolean;
  createdAt: number;
  eventTitle?: string;
  orgName?: string;
}

interface NotificationListProps {
  notifications: Notification[];
}

const typeIcons = {
  event_new: Calendar,
  event_reminder: Bell,
  event_updated: RefreshCw,
};

export function NotificationList({ notifications }: NotificationListProps) {
  const markAsRead = useMutation(api.notifications.mutations.markAsRead);

  if (notifications.length === 0) {
    return (
      <div className="px-4 py-8 text-center text-sm text-muted-foreground">
        No notifications yet
      </div>
    );
  }

  return (
    <div className="max-h-80 overflow-y-auto">
      {notifications.map((notification) => {
        const Icon = typeIcons[notification.type];

        return (
          <button
            key={notification._id}
            className={cn(
              "w-full px-4 py-3 text-left hover:bg-muted/50 border-b last:border-0 flex gap-3",
              !notification.read && "bg-primary/5"
            )}
            onClick={() => {
              if (!notification.read) {
                markAsRead({ notificationId: notification._id });
              }
              if (notification.actionUrl) {
                window.location.href = notification.actionUrl;
              }
            }}
          >
            <div className={cn(
              "size-8 rounded-full flex items-center justify-center shrink-0",
              notification.read ? "bg-muted" : "bg-primary/10"
            )}>
              <Icon className={cn(
                "size-4",
                notification.read ? "text-muted-foreground" : "text-primary"
              )} />
            </div>
            <div className="flex-1 min-w-0">
              <p className={cn(
                "text-sm truncate",
                !notification.read && "font-medium"
              )}>
                {notification.title}
              </p>
              <p className="text-xs text-muted-foreground truncate">
                {notification.body}
              </p>
              <p className="text-xs text-muted-foreground mt-1">
                {formatDistanceToNow(notification.createdAt, { addSuffix: true })}
              </p>
            </div>
            {!notification.read && (
              <div className="size-2 rounded-full bg-primary shrink-0 mt-2" />
            )}
          </button>
        );
      })}
    </div>
  );
}
```

Create index.ts for clean exports:
```typescript
export { NotificationBell } from "./NotificationBell";
export { NotificationList } from "./NotificationList";
```
  </action>
  <verify>Run `bun run lint` - no TypeScript errors in notifications components</verify>
  <done>NotificationBell shows badge with unread count; dropdown shows recent notifications with read/unread styling</done>
</task>

<task type="auto">
  <name>Task 3: Add reminder scheduler and wire into navigation</name>
  <files>convex/notifications/scheduler.ts, src/routes/__root.tsx</files>
  <action>
**Create convex/notifications/scheduler.ts:**
```typescript
import { v } from "convex/values";
import { internalMutation } from "../_generated/server";
import { internal } from "../_generated/api";

const ONE_WEEK = 7 * 24 * 60 * 60 * 1000;
const ONE_DAY = 24 * 60 * 60 * 1000;
const ONE_HOUR = 60 * 60 * 1000;

/**
 * Schedule reminders for a user who viewed an event
 * Called internally from recordEventView via scheduler
 */
export const scheduleRemindersForViewInternal = internalMutation({
  args: { eventId: v.id("events"), userId: v.string() },
  handler: async (ctx, { eventId, userId }) => {

    const event = await ctx.db.get(eventId);
    if (!event) return;

    const profile = await ctx.db
      .query("profiles")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .first();

    const prefs = profile?.eventNotificationPreferences?.reminderTiming;
    if (!prefs) return; // No reminder preferences set

    // Don't schedule if notifications are disabled
    if (profile.eventNotificationPreferences?.frequency === "none") return;

    const now = Date.now();

    // Helper to schedule a reminder
    const scheduleReminder = async (
      timing: "1_week" | "1_day" | "1_hour",
      offset: number
    ) => {
      const scheduledFor = event.startAt - offset;
      if (scheduledFor <= now) return; // Already passed

      // Check if already scheduled
      const existing = await ctx.db
        .query("scheduledReminders")
        .withIndex("by_user_event", (q) => q.eq("userId", userId).eq("eventId", eventId))
        .filter((q) => q.eq(q.field("timing"), timing))
        .first();

      if (existing) return; // Already scheduled

      // Schedule the reminder
      const functionId = await ctx.scheduler.runAt(
        scheduledFor,
        internal.notifications.scheduler.sendReminder,
        { eventId, userId, timing }
      );

      // Track the scheduled function
      await ctx.db.insert("scheduledReminders", {
        eventId,
        userId,
        timing,
        scheduledFunctionId: functionId.toString(),
        scheduledFor,
      });
    };

    // Schedule based on preferences
    if (prefs.oneWeekBefore) {
      await scheduleReminder("1_week", ONE_WEEK);
    }
    if (prefs.oneDayBefore) {
      await scheduleReminder("1_day", ONE_DAY);
    }
    if (prefs.oneHourBefore) {
      await scheduleReminder("1_hour", ONE_HOUR);
    }
  },
});

/**
 * Send a reminder notification (called by scheduler)
 */
export const sendReminder = internalMutation({
  args: {
    eventId: v.id("events"),
    userId: v.string(),
    timing: v.union(v.literal("1_week"), v.literal("1_day"), v.literal("1_hour")),
  },
  handler: async (ctx, { eventId, userId, timing }) => {
    const event = await ctx.db.get(eventId);
    if (!event) return; // Event deleted

    const org = await ctx.db.get(event.orgId);

    const timingLabels = {
      "1_week": "in 1 week",
      "1_day": "tomorrow",
      "1_hour": "in 1 hour",
    };

    // Create in-app notification
    await ctx.db.insert("notifications", {
      userId,
      type: "event_reminder",
      eventId,
      orgId: event.orgId,
      title: `Event ${timingLabels[timing]}: ${event.title}`,
      body: org?.name || "Event reminder",
      actionUrl: event.url,
      read: false,
      createdAt: Date.now(),
    });

    // Remove from scheduled reminders
    const scheduled = await ctx.db
      .query("scheduledReminders")
      .withIndex("by_user_event", (q) => q.eq("userId", userId).eq("eventId", eventId))
      .filter((q) => q.eq(q.field("timing"), timing))
      .first();

    if (scheduled) {
      await ctx.db.delete(scheduled._id);
    }
  },
});

/**
 * Cancel all reminders for an event (call when event is deleted or significantly changed)
 */
export const cancelEventReminders = internalMutation({
  args: { eventId: v.id("events") },
  handler: async (ctx, { eventId }) => {
    const reminders = await ctx.db
      .query("scheduledReminders")
      .withIndex("by_event", (q) => q.eq("eventId", eventId))
      .collect();

    for (const reminder of reminders) {
      try {
        await ctx.scheduler.cancel(reminder.scheduledFunctionId as any);
      } catch {
        // Scheduled function may have already run
      }
      await ctx.db.delete(reminder._id);
    }
  },
});
```

**Update src/routes/__root.tsx:**

Add NotificationBell to the navigation. Find where the user menu/auth buttons are rendered and add the bell:

1. Import NotificationBell:
```typescript
import { NotificationBell } from "~/components/notifications";
```

2. Add NotificationBell in the header, before the user avatar/menu (only for authenticated users):
```tsx
{/* In the nav section, after links but before user menu */}
<NotificationBell />
```

Place it in the flex container with other nav items. The component handles its own auth check and returns null for unauthenticated users.
  </action>
  <verify>
1. Run `bun run lint` - no errors
2. Start dev server, log in
3. Bell icon appears in navigation
4. Click bell - dropdown shows "No notifications yet"
5. Unread count badge not visible when 0
  </verify>
  <done>Notification bell renders in navigation with dropdown; reminder scheduler creates in-app notifications at configured times before events</done>
</task>

</tasks>

<verification>
- [ ] NotificationBell renders in navigation for authenticated users
- [ ] Dropdown shows recent notifications or empty state
- [ ] Unread count badge shows when > 0
- [ ] markAsRead mutation updates notification state
- [ ] markAllAsRead clears all unread notifications
- [ ] recordEventView calls scheduleRemindersForViewInternal via scheduler.runAfter
- [ ] scheduleRemindersForViewInternal creates scheduled functions for enabled reminders
- [ ] sendReminder creates in-app notification
- [ ] No TypeScript errors
</verification>

<success_criteria>
1. Bell icon visible in navigation when logged in
2. Badge shows unread count (hidden when 0)
3. Dropdown lists recent notifications with icons by type
4. Clicking notification marks it read
5. "Mark all read" clears unread state
6. `bun run lint` passes
</success_criteria>

<output>
After completion, create `.planning/phases/13-event-notifications/13-03-SUMMARY.md`
</output>
