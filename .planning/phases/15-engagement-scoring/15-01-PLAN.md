---
phase: 15-engagement-scoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/engagement/prompts.ts
  - convex/engagement/compute.ts
  - convex/engagement/queries.ts
  - convex/engagement/mutations.ts
  - convex/crons.ts
autonomous: true

must_haves:
  truths:
    - "Engagement levels are computed per user-org pair"
    - "LLM generates both admin and user explanations"
    - "Daily cron recomputes stale engagement scores"
    - "Expired overrides are cleared during computation"
  artifacts:
    - path: "convex/schema.ts"
      provides: "memberEngagement and engagementOverrideHistory tables"
      contains: "memberEngagement"
    - path: "convex/engagement/compute.ts"
      provides: "LLM-based engagement classification action"
      exports: ["computeOrgEngagement"]
    - path: "convex/engagement/prompts.ts"
      provides: "Engagement classification tool and system prompt"
      exports: ["classifyEngagementTool", "ENGAGEMENT_SYSTEM_PROMPT"]
    - path: "convex/crons.ts"
      provides: "Daily engagement computation cron"
      contains: "compute-engagement-scores"
  key_links:
    - from: "convex/engagement/compute.ts"
      to: "convex/engagement/prompts.ts"
      via: "imports tool definition"
      pattern: "classifyEngagementTool"
    - from: "convex/crons.ts"
      to: "convex/engagement/compute.ts"
      via: "internal action reference"
      pattern: "internal.engagement.compute"
---

<objective>
Create engagement scoring backend with LLM-based classification and daily batch computation.

Purpose: Enable the system to automatically classify member engagement levels (Highly Engaged / Moderate / At Risk / New / Inactive) with natural language explanations that help org admins understand member activity.

Output: Schema tables, LLM classification action, and daily cron job for engagement computation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-engagement-scoring/15-CONTEXT.md
@.planning/phases/15-engagement-scoring/15-RESEARCH.md
@convex/schema.ts
@convex/crons.ts
@convex/matching/compute.ts
@convex/matching/prompts.ts
@convex/attendance/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add engagement schema tables</name>
  <files>convex/schema.ts</files>
  <action>
Add two new tables to the schema:

1. `memberEngagement` table:
```typescript
memberEngagement: defineTable({
  userId: v.string(),
  orgId: v.id("organizations"),

  // Computed engagement level
  level: v.union(
    v.literal("highly_engaged"),
    v.literal("moderate"),
    v.literal("at_risk"),
    v.literal("new"),
    v.literal("inactive")
  ),

  // Explanations from LLM
  adminExplanation: v.string(),  // Detailed with signals for admins
  userExplanation: v.string(),   // Friendly messaging for users

  // Input signals (stored for audit/debugging)
  signals: v.object({
    eventsAttended90d: v.number(),
    lastAttendedAt: v.optional(v.number()),
    rsvpCount90d: v.number(),
    profileUpdatedAt: v.optional(v.number()),
    joinedAt: v.number(),
  }),

  // Override (optional - only set when admin overrides)
  override: v.optional(v.object({
    level: v.union(
      v.literal("highly_engaged"),
      v.literal("moderate"),
      v.literal("at_risk"),
      v.literal("new"),
      v.literal("inactive")
    ),
    notes: v.string(),
    overriddenBy: v.id("orgMemberships"),
    overriddenAt: v.number(),
    expiresAt: v.optional(v.number()),
  })),

  // Metadata
  computedAt: v.number(),
  modelVersion: v.string(),
})
.index("by_user_org", ["userId", "orgId"])
.index("by_org", ["orgId"])
.index("by_org_level", ["orgId", "level"])
```

2. `engagementOverrideHistory` table:
```typescript
engagementOverrideHistory: defineTable({
  engagementId: v.id("memberEngagement"),
  userId: v.string(),
  orgId: v.id("organizations"),

  previousLevel: v.string(),
  newLevel: v.string(),
  notes: v.string(),

  action: v.union(v.literal("override"), v.literal("clear")),
  performedBy: v.id("orgMemberships"),
  performedAt: v.number(),
})
.index("by_engagement", ["engagementId"])
.index("by_org", ["orgId"])
```
  </action>
  <verify>Run `bun run dev:convex` and confirm schema pushes without errors</verify>
  <done>Both tables exist in schema with proper indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create engagement prompts and tool definition</name>
  <files>convex/engagement/prompts.ts</files>
  <action>
Create new file with LLM tool definition and prompt following the pattern from `convex/matching/prompts.ts`:

1. Define `EngagementSignals` interface for input data
2. Define `EngagementThresholds` interface with configurable thresholds (from CONTEXT.md):
   - Highly Engaged: 3+ events in 90 days
   - Moderate: 1-2 events in 90 days
   - At Risk: No events in 90+ days but was previously active
   - New: Joined within 60 days
   - Inactive: No activity in 180+ days

3. Create `ENGAGEMENT_SYSTEM_PROMPT` string:
   - CRM context for org admins
   - Explain the engagement levels
   - Instruct to generate both admin (detailed with signals) and user (friendly) explanations
   - Include org name in explanations
   - Per CONTEXT.md: user-facing never shows "At Risk" - use softer language

4. Create `classifyEngagementTool` (Anthropic.Tool):
   - name: "classify_engagement"
   - input_schema with: level (enum), adminExplanation (string), userExplanation (string)
   - All fields required

5. Create `buildEngagementContext(orgName: string, memberName: string, signals: EngagementSignals, thresholds: EngagementThresholds): string` function that builds the context string for the LLM

6. Export `EngagementResult` interface for typed tool output
  </action>
  <verify>File exists and exports compile without TypeScript errors</verify>
  <done>Engagement prompts module exists with tool definition, system prompt, and context builder</done>
</task>

<task type="auto">
  <name>Task 3: Create engagement compute action and cron</name>
  <files>convex/engagement/compute.ts, convex/engagement/queries.ts, convex/engagement/mutations.ts, convex/crons.ts</files>
  <action>
Create engagement computation files:

**convex/engagement/queries.ts:**
1. `getActiveOrgs` (internal query) - returns all orgs with members
2. `getOrgMembersForEngagement` (internal query) - returns members needing score computation:
   - All members of an org
   - Include: userId, profile (name, updatedAt), membership (joinedAt)
   - Optionally filter to members with stale scores (computedAt > 24h ago) for efficiency

3. `getMemberEngagement` (public query) - get engagement for current user in an org (for user-facing display)
4. `getMemberEngagementForAdmin` (public query) - get engagement for any member in org (admin only, requires org admin check)

**convex/engagement/mutations.ts:**
1. `saveEngagementScore` (internal mutation) - upserts memberEngagement record
2. `overrideEngagement` (public mutation) - admin override with required notes:
   - Require org admin via requireOrgAdmin helper
   - Save to engagementOverrideHistory before updating
   - Set override object on memberEngagement
3. `clearOverride` (public mutation) - admin clears override:
   - Require org admin
   - Save to engagementOverrideHistory with action: "clear"
   - Remove override from memberEngagement

**convex/engagement/compute.ts:**
Add `"use node"` at top for Anthropic SDK access.

1. `getEngagementSignals` helper function:
   - Query attendance table for user+org
   - Count attended/partial in last 90 days
   - Find last attendance date
   - Get RSVP count (use eventViews as proxy)
   - Get membership joinedAt
   - Get profile updatedAt
   - Return EngagementSignals object

2. `computeMemberEngagement` (internal action):
   - Args: userId, orgId, orgName, memberName
   - Gather signals via helper
   - Build context string
   - Call Claude Haiku with forced tool_choice
   - Return classification result

3. `computeOrgEngagement` (internal action):
   - Args: orgId
   - Get org details
   - Get all members needing computation
   - For each member (with 100ms delay between calls for rate limiting):
     - Check if existing score has unexpired override - if so, skip
     - Check if override expired - if so, clear it first
     - Call computeMemberEngagement
     - Save result via internal mutation
   - Return count of members processed

4. `runEngagementBatch` (internal action):
   - Get all active orgs
   - For each org, call computeOrgEngagement
   - Log summary

**convex/crons.ts:**
Add new daily cron at 4 AM UTC (before match alerts at 8 AM):
```typescript
crons.daily(
  "compute-engagement-scores",
  { hourUTC: 4, minuteUTC: 0 },
  internal.engagement.compute.runEngagementBatch
);
```
  </action>
  <verify>Run `bun run dev:convex` and confirm all functions register. Check Convex dashboard shows the new cron job.</verify>
  <done>Engagement computation pipeline exists with queries, mutations, compute action, and daily cron</done>
</task>

</tasks>

<verification>
1. Schema pushed successfully with both engagement tables
2. `bun run lint` passes
3. Convex dashboard shows `compute-engagement-scores` cron scheduled for 4 AM UTC
4. All engagement functions appear in Convex dashboard (queries, mutations, actions)
</verification>

<success_criteria>
- memberEngagement table stores engagement levels per user-org
- LLM classification tool produces both admin and user explanations
- Daily cron computes engagement for all org members
- Override expiration is handled during computation
- No new npm dependencies (using existing @anthropic-ai/sdk)
</success_criteria>

<output>
After completion, create `.planning/phases/15-engagement-scoring/15-01-SUMMARY.md`
</output>
