---
phase: 16-crm-dashboard-programs
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/orgs/members.ts
autonomous: true

must_haves:
  truths:
    - "Query returns member profile data respecting privacy settings"
    - "Query returns per-member attendance history"
    - "Query returns engagement override history for audit"
  artifacts:
    - path: "convex/orgs/members.ts"
      provides: "Member profile and history queries"
      exports: ["getMemberProfileForAdmin", "getMemberAttendanceHistory", "getMemberEngagementHistory"]
  key_links:
    - from: "convex/orgs/members.ts"
      to: "convex/schema.ts"
      via: "database queries"
      pattern: "ctx\\.db\\.query"
---

<objective>
Create backend queries for member profile view with privacy controls, attendance history, and engagement history.

Purpose: CONTEXT.md specifies "Full history view: engagement timeline, all attendance records, program participation, override history" and "Respect all member privacy settings - admins see exactly what member has made visible to their org". This plan creates the data layer for the member profile page.

Output: New convex/orgs/members.ts file with queries for admin member view.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-crm-dashboard-programs/16-CONTEXT.md
@.planning/phases/16-crm-dashboard-programs/16-RESEARCH.md
@convex/schema.ts
@convex/orgs/admin.ts
@convex/engagement/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create getMemberProfileForAdmin query</name>
  <files>convex/orgs/members.ts</files>
  <action>
    Create new file convex/orgs/members.ts with privacy-controlled member profile query.

    Use the pattern from 16-RESEARCH.md Pattern 2:

    ```typescript
    import { v } from "convex/values";
    import { query } from "../_generated/server";
    import { auth } from "../auth";
    import type { Doc, Id } from "../_generated/dataModel";
    import type { QueryCtx } from "../_generated/server";

    // Helper: Require current user is an admin of the given org
    async function requireOrgAdmin(
      ctx: QueryCtx,
      orgId: Id<"organizations">
    ): Promise<Doc<"orgMemberships">> {
      const userId = await auth.getUserId(ctx);
      if (!userId) throw new Error("Not authenticated");

      const membership = await ctx.db
        .query("orgMemberships")
        .withIndex("by_user", (q) => q.eq("userId", userId))
        .filter((q) => q.eq(q.field("orgId"), orgId))
        .first();

      if (!membership) throw new Error("Not a member of this organization");
      if (membership.role !== "admin") throw new Error("Admin access required");

      return membership;
    }

    export const getMemberProfileForAdmin = query({
      args: {
        orgId: v.id("organizations"),
        userId: v.string(),
      },
      handler: async (ctx, { orgId, userId }) => {
        await requireOrgAdmin(ctx, orgId);

        // Get profile
        const profile = await ctx.db
          .query("profiles")
          .withIndex("by_user", (q) => q.eq("userId", userId))
          .first();

        if (!profile) return null;

        // Get membership
        const membership = await ctx.db
          .query("orgMemberships")
          .withIndex("by_user", (q) => q.eq("userId", userId))
          .filter((q) => q.eq(q.field("orgId"), orgId))
          .first();

        if (!membership) return null;

        // Check if member has hidden themselves from this org
        const hiddenOrgs = profile.privacySettings?.hiddenFromOrgs ?? [];
        if (hiddenOrgs.includes(orgId.toString())) {
          return { restricted: true, reason: "Member has hidden their profile from this organization" };
        }

        // Apply section visibility (respect member's choices)
        const visibility = profile.privacySettings?.sectionVisibility ?? {};
        const defaultVis = profile.privacySettings?.defaultVisibility ?? "private";

        // Helper: check if section is visible to org admin
        // "public" or "connections" visible to org admin (org membership = connection)
        const isVisible = (section: string): boolean => {
          const sectionVis = (visibility as Record<string, string>)[section] ?? defaultVis;
          return sectionVis !== "private";
        };

        // Get user email
        const user = await ctx.db.get("users", userId as Id<"users">);
        const email = user?.email ?? null;

        return {
          restricted: false,
          profile: {
            name: profile.name, // Always visible (needed for identification)
            headline: isVisible("basicInfo") ? profile.headline : null,
            location: isVisible("basicInfo") ? profile.location : null,
            pronouns: isVisible("basicInfo") ? profile.pronouns : null,
            education: isVisible("education") ? profile.education : null,
            workHistory: isVisible("workHistory") ? profile.workHistory : null,
            skills: isVisible("skills") ? profile.skills : null,
            careerGoals: isVisible("careerGoals") ? profile.careerGoals : null,
            seeking: isVisible("careerGoals") ? profile.seeking : null,
            aiSafetyInterests: isVisible("careerGoals") ? profile.aiSafetyInterests : null,
            enrichmentSummary: isVisible("careerGoals") ? profile.enrichmentSummary : null,
          },
          email,
          membership: {
            _id: membership._id,
            joinedAt: membership.joinedAt,
            role: membership.role,
            directoryVisibility: membership.directoryVisibility,
          },
          visibleSections: {
            basicInfo: isVisible("basicInfo"),
            education: isVisible("education"),
            workHistory: isVisible("workHistory"),
            skills: isVisible("skills"),
            careerGoals: isVisible("careerGoals"),
          },
        };
      },
    });
    ```
  </action>
  <verify>
    `bun run lint` passes. File exists at convex/orgs/members.ts with getMemberProfileForAdmin export.
  </verify>
  <done>
    getMemberProfileForAdmin query returns privacy-controlled profile data with visibility flags.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create getMemberAttendanceHistory query</name>
  <files>convex/orgs/members.ts</files>
  <action>
    Add query to get member's attendance history for the org:

    ```typescript
    export const getMemberAttendanceHistory = query({
      args: {
        orgId: v.id("organizations"),
        userId: v.string(),
      },
      handler: async (ctx, { orgId, userId }) => {
        await requireOrgAdmin(ctx, orgId);

        // Verify user is a member of this org
        const membership = await ctx.db
          .query("orgMemberships")
          .withIndex("by_user", (q) => q.eq("userId", userId))
          .filter((q) => q.eq(q.field("orgId"), orgId))
          .first();

        if (!membership) {
          throw new Error("User is not a member of this organization");
        }

        // Get all attendance records for this user in this org
        const attendanceRecords = await ctx.db
          .query("attendance")
          .withIndex("by_user", (q) => q.eq("userId", userId))
          .filter((q) => q.eq(q.field("orgId"), orgId))
          .collect();

        // Enrich with event details
        const enrichedRecords = await Promise.all(
          attendanceRecords.map(async (record) => {
            const event = await ctx.db.get("events", record.eventId);
            return {
              _id: record._id,
              status: record.status,
              respondedAt: record.respondedAt,
              feedbackRating: record.feedbackRating,
              feedbackText: record.feedbackText,
              createdAt: record.createdAt,
              event: event ? {
                _id: event._id,
                title: event.title,
                startAt: event.startAt,
                location: event.location,
                isVirtual: event.isVirtual,
              } : null,
            };
          })
        );

        // Sort by event date descending
        return enrichedRecords.sort((a, b) =>
          (b.event?.startAt ?? 0) - (a.event?.startAt ?? 0)
        );
      },
    });
    ```

    This returns:
    - Attendance status (attended, partial, not_attended, unknown)
    - Response timestamp
    - Feedback if provided
    - Event details (title, date, location)
    - Sorted by event date descending (most recent first)
  </action>
  <verify>
    `bun run lint` passes. Query export exists in convex/orgs/members.ts.
  </verify>
  <done>
    getMemberAttendanceHistory query returns attendance records with event details, sorted by date.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create getMemberEngagementHistory query</name>
  <files>convex/orgs/members.ts</files>
  <action>
    Add query to get member's engagement data and override history:

    ```typescript
    export const getMemberEngagementHistory = query({
      args: {
        orgId: v.id("organizations"),
        userId: v.string(),
      },
      handler: async (ctx, { orgId, userId }) => {
        await requireOrgAdmin(ctx, orgId);

        // Verify user is a member of this org
        const membership = await ctx.db
          .query("orgMemberships")
          .withIndex("by_user", (q) => q.eq("userId", userId))
          .filter((q) => q.eq(q.field("orgId"), orgId))
          .first();

        if (!membership) {
          throw new Error("User is not a member of this organization");
        }

        // Get current engagement record
        const engagement = await ctx.db
          .query("memberEngagement")
          .withIndex("by_user_org", (q) => q.eq("userId", userId).eq("orgId", orgId))
          .first();

        if (!engagement) {
          return {
            current: null,
            history: [],
          };
        }

        // Get override history
        const overrideHistory = await ctx.db
          .query("engagementOverrideHistory")
          .withIndex("by_engagement", (q) => q.eq("engagementId", engagement._id))
          .collect();

        // Enrich history with admin names
        const enrichedHistory = await Promise.all(
          overrideHistory.map(async (record) => {
            // Get admin membership to find admin user
            const adminMembership = await ctx.db.get("orgMemberships", record.performedBy);
            let adminName = "Unknown admin";

            if (adminMembership) {
              const adminProfile = await ctx.db
                .query("profiles")
                .withIndex("by_user", (q) => q.eq("userId", adminMembership.userId))
                .first();
              adminName = adminProfile?.name ?? "Admin";
            }

            return {
              _id: record._id,
              action: record.action,
              previousLevel: record.previousLevel,
              newLevel: record.newLevel,
              notes: record.notes,
              adminName,
              performedAt: record.performedAt,
            };
          })
        );

        // Sort by date descending
        enrichedHistory.sort((a, b) => b.performedAt - a.performedAt);

        return {
          current: {
            level: engagement.override?.level ?? engagement.level,
            computedLevel: engagement.level,
            adminExplanation: engagement.adminExplanation,
            userExplanation: engagement.userExplanation,
            signals: engagement.signals,
            hasOverride: !!engagement.override,
            overrideNotes: engagement.override?.notes,
            overrideExpiresAt: engagement.override?.expiresAt,
            computedAt: engagement.computedAt,
          },
          history: enrichedHistory,
        };
      },
    });
    ```

    This returns:
    - Current engagement level (with override if active)
    - Computed level (what LLM determined)
    - Explanations and signals
    - Override history with admin names and timestamps
  </action>
  <verify>
    `bun run lint` passes. All three queries export from convex/orgs/members.ts.
  </verify>
  <done>
    getMemberEngagementHistory query returns current engagement state and full override audit trail.
  </done>
</task>

</tasks>

<verification>
1. `bun run lint` passes
2. `npx tsc --noEmit` shows no type errors
3. Check convex/_generated/api.d.ts includes new queries after running dev server
4. Queries are accessible via api.orgs.members namespace
</verification>

<success_criteria>
- convex/orgs/members.ts exists with three query exports
- getMemberProfileForAdmin respects privacy settings
- getMemberAttendanceHistory returns event-enriched attendance records
- getMemberEngagementHistory returns current state and override history
- All queries require admin authentication
</success_criteria>

<output>
After completion, create `.planning/phases/16-crm-dashboard-programs/16-03-SUMMARY.md`
</output>
