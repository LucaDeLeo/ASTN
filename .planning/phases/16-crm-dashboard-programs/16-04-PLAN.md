---
phase: 16-crm-dashboard-programs
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/programs.ts
autonomous: true

must_haves:
  truths:
    - "Programs table exists with org, type, status, and completion criteria fields"
    - "ProgramParticipation table tracks member enrollment and completion"
    - "Admin can create, update, and delete programs"
    - "Admin can enroll members in programs"
    - "System auto-marks completion when criteria met"
  artifacts:
    - path: "convex/schema.ts"
      provides: "programs and programParticipation table definitions"
      contains: ["defineTable", "programs:", "programParticipation:"]
    - path: "convex/programs.ts"
      provides: "Program CRUD and enrollment mutations"
      exports: ["createProgram", "updateProgram", "deleteProgram", "enrollMember", "unenrollMember", "getOrgPrograms", "getProgramParticipants"]
  key_links:
    - from: "convex/programs.ts"
      to: "convex/schema.ts"
      via: "table references"
      pattern: "ctx\\.db\\.insert\\(\"programs\""
---

<objective>
Create schema and backend for org-specific program tracking (reading groups, fellowships, etc.).

Purpose: CONTEXT.md specifies "Flexible with templates: reading groups, fellowships, mentorship, cohorts - plus custom types" and "Participation tracking: link events for auto-counting, plus manual entry for non-event activities". This enables orgs to track member participation in structured programs.

Output: Schema tables for programs and participation, plus CRUD and enrollment mutations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-crm-dashboard-programs/16-CONTEXT.md
@.planning/phases/16-crm-dashboard-programs/16-RESEARCH.md
@convex/schema.ts
@convex/orgs/admin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add programs and programParticipation tables to schema</name>
  <files>convex/schema.ts</files>
  <action>
    Add new tables to schema.ts following the pattern from 16-RESEARCH.md:

    ```typescript
    // Programs (org-specific activities like reading groups, fellowships)
    programs: defineTable({
      orgId: v.id("organizations"),

      // Identity
      name: v.string(),
      slug: v.string(), // URL-safe identifier within org
      description: v.optional(v.string()),

      // Program type
      type: v.union(
        v.literal("reading_group"),
        v.literal("fellowship"),
        v.literal("mentorship"),
        v.literal("cohort"),
        v.literal("workshop_series"),
        v.literal("custom")
      ),

      // Dates
      startDate: v.optional(v.number()), // Unix timestamp
      endDate: v.optional(v.number()),
      status: v.union(
        v.literal("planning"),
        v.literal("active"),
        v.literal("completed"),
        v.literal("archived")
      ),

      // Enrollment configuration
      enrollmentMethod: v.union(
        v.literal("admin_only"),      // Only admins can add members
        v.literal("self_enroll"),     // Members can join freely
        v.literal("approval_required") // Members request, admin approves
      ),
      maxParticipants: v.optional(v.number()),

      // Completion criteria (optional)
      completionCriteria: v.optional(v.object({
        type: v.union(
          v.literal("attendance_count"),
          v.literal("attendance_percentage"),
          v.literal("manual")
        ),
        requiredCount: v.optional(v.number()),       // For attendance_count
        requiredPercentage: v.optional(v.number()),  // For attendance_percentage
      })),

      // Linked events (for auto-attendance counting)
      linkedEventIds: v.optional(v.array(v.id("events"))),

      // Metadata
      createdBy: v.id("orgMemberships"),
      createdAt: v.number(),
      updatedAt: v.number(),
    })
      .index("by_org", ["orgId"])
      .index("by_org_status", ["orgId", "status"])
      .index("by_org_slug", ["orgId", "slug"]),

    // Program participation tracking
    programParticipation: defineTable({
      programId: v.id("programs"),
      userId: v.string(),
      orgId: v.id("organizations"), // Denormalized for queries

      // Enrollment status
      status: v.union(
        v.literal("pending"),     // Requested, awaiting approval
        v.literal("enrolled"),    // Active participant
        v.literal("completed"),   // Finished program (graduated)
        v.literal("withdrawn"),   // Left program
        v.literal("removed")      // Removed by admin
      ),

      // Tracking
      enrolledAt: v.number(),
      completedAt: v.optional(v.number()),

      // Manual attendance tracking (for non-event activities)
      manualAttendanceCount: v.optional(v.number()),
      attendanceNotes: v.optional(v.string()),

      // Admin notes
      adminNotes: v.optional(v.string()),

      // Enrollment request (if approval_required)
      requestedAt: v.optional(v.number()),
      approvedBy: v.optional(v.id("orgMemberships")),
      approvedAt: v.optional(v.number()),
    })
      .index("by_program", ["programId"])
      .index("by_user", ["userId"])
      .index("by_org", ["orgId"])
      .index("by_program_status", ["programId", "status"])
      .index("by_user_org", ["userId", "orgId"]),
    ```

    Add these tables at the end of the schema, before the closing `});`.
  </action>
  <verify>
    `bun run lint` passes. `bun run dev:convex` starts without schema errors.
  </verify>
  <done>
    Schema includes programs and programParticipation tables with all required fields and indexes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create program CRUD mutations and queries</name>
  <files>convex/programs.ts</files>
  <action>
    Create new file convex/programs.ts with program management functions:

    ```typescript
    import { v } from "convex/values";
    import { mutation, query } from "./_generated/server";
    import { auth } from "./auth";
    import type { Doc, Id } from "./_generated/dataModel";
    import type { MutationCtx, QueryCtx } from "./_generated/server";

    // Helper: Require org admin
    async function requireOrgAdmin(
      ctx: QueryCtx | MutationCtx,
      orgId: Id<"organizations">
    ): Promise<Doc<"orgMemberships">> {
      const userId = await auth.getUserId(ctx);
      if (!userId) throw new Error("Not authenticated");

      const membership = await ctx.db
        .query("orgMemberships")
        .withIndex("by_user", (q) => q.eq("userId", userId))
        .filter((q) => q.eq(q.field("orgId"), orgId))
        .first();

      if (!membership) throw new Error("Not a member of this organization");
      if (membership.role !== "admin") throw new Error("Admin access required");

      return membership;
    }

    // Helper: Generate URL-safe slug
    function generateSlug(name: string): string {
      return name
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-|-$/g, "")
        .slice(0, 50);
    }

    // Get all programs for an org
    export const getOrgPrograms = query({
      args: {
        orgId: v.id("organizations"),
        status: v.optional(v.union(
          v.literal("planning"),
          v.literal("active"),
          v.literal("completed"),
          v.literal("archived")
        )),
      },
      handler: async (ctx, { orgId, status }) => {
        await requireOrgAdmin(ctx, orgId);

        let programs;
        if (status) {
          programs = await ctx.db
            .query("programs")
            .withIndex("by_org_status", (q) => q.eq("orgId", orgId).eq("status", status))
            .collect();
        } else {
          programs = await ctx.db
            .query("programs")
            .withIndex("by_org", (q) => q.eq("orgId", orgId))
            .collect();
        }

        // Add participant counts
        const programsWithCounts = await Promise.all(
          programs.map(async (program) => {
            const participants = await ctx.db
              .query("programParticipation")
              .withIndex("by_program_status", (q) =>
                q.eq("programId", program._id).eq("status", "enrolled")
              )
              .collect();

            return {
              ...program,
              participantCount: participants.length,
            };
          })
        );

        return programsWithCounts;
      },
    });

    // Create a new program
    export const createProgram = mutation({
      args: {
        orgId: v.id("organizations"),
        name: v.string(),
        description: v.optional(v.string()),
        type: v.union(
          v.literal("reading_group"),
          v.literal("fellowship"),
          v.literal("mentorship"),
          v.literal("cohort"),
          v.literal("workshop_series"),
          v.literal("custom")
        ),
        startDate: v.optional(v.number()),
        endDate: v.optional(v.number()),
        enrollmentMethod: v.union(
          v.literal("admin_only"),
          v.literal("self_enroll"),
          v.literal("approval_required")
        ),
        maxParticipants: v.optional(v.number()),
        completionCriteria: v.optional(v.object({
          type: v.union(
            v.literal("attendance_count"),
            v.literal("attendance_percentage"),
            v.literal("manual")
          ),
          requiredCount: v.optional(v.number()),
          requiredPercentage: v.optional(v.number()),
        })),
      },
      handler: async (ctx, args) => {
        const adminMembership = await requireOrgAdmin(ctx, args.orgId);

        // Generate unique slug
        let slug = generateSlug(args.name);
        const existingSlug = await ctx.db
          .query("programs")
          .withIndex("by_org_slug", (q) => q.eq("orgId", args.orgId).eq("slug", slug))
          .first();

        if (existingSlug) {
          slug = `${slug}-${Date.now()}`;
        }

        const now = Date.now();
        const programId = await ctx.db.insert("programs", {
          orgId: args.orgId,
          name: args.name,
          slug,
          description: args.description,
          type: args.type,
          startDate: args.startDate,
          endDate: args.endDate,
          status: "planning",
          enrollmentMethod: args.enrollmentMethod,
          maxParticipants: args.maxParticipants,
          completionCriteria: args.completionCriteria,
          linkedEventIds: [],
          createdBy: adminMembership._id,
          createdAt: now,
          updatedAt: now,
        });

        return { programId, slug };
      },
    });

    // Update a program
    export const updateProgram = mutation({
      args: {
        programId: v.id("programs"),
        name: v.optional(v.string()),
        description: v.optional(v.string()),
        status: v.optional(v.union(
          v.literal("planning"),
          v.literal("active"),
          v.literal("completed"),
          v.literal("archived")
        )),
        startDate: v.optional(v.number()),
        endDate: v.optional(v.number()),
        enrollmentMethod: v.optional(v.union(
          v.literal("admin_only"),
          v.literal("self_enroll"),
          v.literal("approval_required")
        )),
        maxParticipants: v.optional(v.number()),
        completionCriteria: v.optional(v.object({
          type: v.union(
            v.literal("attendance_count"),
            v.literal("attendance_percentage"),
            v.literal("manual")
          ),
          requiredCount: v.optional(v.number()),
          requiredPercentage: v.optional(v.number()),
        })),
        linkedEventIds: v.optional(v.array(v.id("events"))),
      },
      handler: async (ctx, { programId, ...updates }) => {
        const program = await ctx.db.get("programs", programId);
        if (!program) throw new Error("Program not found");

        await requireOrgAdmin(ctx, program.orgId);

        const patchData: Record<string, unknown> = { updatedAt: Date.now() };

        if (updates.name !== undefined) patchData.name = updates.name;
        if (updates.description !== undefined) patchData.description = updates.description;
        if (updates.status !== undefined) patchData.status = updates.status;
        if (updates.startDate !== undefined) patchData.startDate = updates.startDate;
        if (updates.endDate !== undefined) patchData.endDate = updates.endDate;
        if (updates.enrollmentMethod !== undefined) patchData.enrollmentMethod = updates.enrollmentMethod;
        if (updates.maxParticipants !== undefined) patchData.maxParticipants = updates.maxParticipants;
        if (updates.completionCriteria !== undefined) patchData.completionCriteria = updates.completionCriteria;
        if (updates.linkedEventIds !== undefined) patchData.linkedEventIds = updates.linkedEventIds;

        await ctx.db.patch("programs", programId, patchData);

        return { success: true };
      },
    });

    // Delete a program (soft delete by archiving)
    export const deleteProgram = mutation({
      args: {
        programId: v.id("programs"),
      },
      handler: async (ctx, { programId }) => {
        const program = await ctx.db.get("programs", programId);
        if (!program) throw new Error("Program not found");

        await requireOrgAdmin(ctx, program.orgId);

        // Archive instead of hard delete
        await ctx.db.patch("programs", programId, {
          status: "archived",
          updatedAt: Date.now(),
        });

        return { success: true };
      },
    });
    ```
  </action>
  <verify>
    `bun run lint` passes. File exists with createProgram, updateProgram, deleteProgram, getOrgPrograms exports.
  </verify>
  <done>
    Program CRUD mutations and getOrgPrograms query created with admin auth checks.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create enrollment mutations and completion logic</name>
  <files>convex/programs.ts</files>
  <action>
    Add enrollment management and completion checking to convex/programs.ts:

    ```typescript
    // Get program participants
    export const getProgramParticipants = query({
      args: {
        programId: v.id("programs"),
      },
      handler: async (ctx, { programId }) => {
        const program = await ctx.db.get("programs", programId);
        if (!program) throw new Error("Program not found");

        await requireOrgAdmin(ctx, program.orgId);

        const participations = await ctx.db
          .query("programParticipation")
          .withIndex("by_program", (q) => q.eq("programId", programId))
          .collect();

        // Enrich with profile data
        const enrichedParticipants = await Promise.all(
          participations.map(async (p) => {
            const profile = await ctx.db
              .query("profiles")
              .withIndex("by_user", (q) => q.eq("userId", p.userId))
              .first();

            return {
              ...p,
              memberName: profile?.name ?? "Unknown",
              memberEmail: null, // Privacy: don't expose email in list
            };
          })
        );

        return enrichedParticipants;
      },
    });

    // Enroll a member in a program
    export const enrollMember = mutation({
      args: {
        programId: v.id("programs"),
        userId: v.string(),
        adminNotes: v.optional(v.string()),
      },
      handler: async (ctx, { programId, userId, adminNotes }) => {
        const program = await ctx.db.get("programs", programId);
        if (!program) throw new Error("Program not found");

        const adminMembership = await requireOrgAdmin(ctx, program.orgId);

        // Verify user is a member of the org
        const userMembership = await ctx.db
          .query("orgMemberships")
          .withIndex("by_user", (q) => q.eq("userId", userId))
          .filter((q) => q.eq(q.field("orgId"), program.orgId))
          .first();

        if (!userMembership) {
          throw new Error("User is not a member of this organization");
        }

        // Check if already enrolled
        const existing = await ctx.db
          .query("programParticipation")
          .withIndex("by_program", (q) => q.eq("programId", programId))
          .filter((q) => q.eq(q.field("userId"), userId))
          .first();

        if (existing && (existing.status === "enrolled" || existing.status === "pending")) {
          throw new Error("User is already enrolled or has a pending enrollment");
        }

        // Check capacity
        if (program.maxParticipants) {
          const enrolledCount = await ctx.db
            .query("programParticipation")
            .withIndex("by_program_status", (q) =>
              q.eq("programId", programId).eq("status", "enrolled")
            )
            .collect();

          if (enrolledCount.length >= program.maxParticipants) {
            throw new Error("Program is at capacity");
          }
        }

        const now = Date.now();
        const participationId = await ctx.db.insert("programParticipation", {
          programId,
          userId,
          orgId: program.orgId,
          status: "enrolled",
          enrolledAt: now,
          adminNotes,
          approvedBy: adminMembership._id,
          approvedAt: now,
        });

        return { participationId };
      },
    });

    // Unenroll/remove a member from a program
    export const unenrollMember = mutation({
      args: {
        participationId: v.id("programParticipation"),
        reason: v.optional(v.string()),
      },
      handler: async (ctx, { participationId, reason }) => {
        const participation = await ctx.db.get("programParticipation", participationId);
        if (!participation) throw new Error("Participation not found");

        await requireOrgAdmin(ctx, participation.orgId);

        await ctx.db.patch("programParticipation", participationId, {
          status: "removed",
          adminNotes: reason
            ? `${participation.adminNotes ?? ""}\nRemoved: ${reason}`.trim()
            : participation.adminNotes,
        });

        return { success: true };
      },
    });

    // Mark a participant as completed (manual completion)
    export const markCompleted = mutation({
      args: {
        participationId: v.id("programParticipation"),
        notes: v.optional(v.string()),
      },
      handler: async (ctx, { participationId, notes }) => {
        const participation = await ctx.db.get("programParticipation", participationId);
        if (!participation) throw new Error("Participation not found");

        await requireOrgAdmin(ctx, participation.orgId);

        if (participation.status !== "enrolled") {
          throw new Error("Can only mark enrolled participants as completed");
        }

        await ctx.db.patch("programParticipation", participationId, {
          status: "completed",
          completedAt: Date.now(),
          adminNotes: notes
            ? `${participation.adminNotes ?? ""}\nCompleted: ${notes}`.trim()
            : participation.adminNotes,
        });

        return { success: true };
      },
    });

    // Update manual attendance count for a participant
    export const updateManualAttendance = mutation({
      args: {
        participationId: v.id("programParticipation"),
        count: v.number(),
        notes: v.optional(v.string()),
      },
      handler: async (ctx, { participationId, count, notes }) => {
        const participation = await ctx.db.get("programParticipation", participationId);
        if (!participation) throw new Error("Participation not found");

        await requireOrgAdmin(ctx, participation.orgId);

        await ctx.db.patch("programParticipation", participationId, {
          manualAttendanceCount: count,
          attendanceNotes: notes,
        });

        // Check if this triggers auto-completion
        const program = await ctx.db.get("programs", participation.programId);
        if (program?.completionCriteria?.type === "attendance_count") {
          const required = program.completionCriteria.requiredCount ?? 0;
          if (count >= required && participation.status === "enrolled") {
            await ctx.db.patch("programParticipation", participationId, {
              status: "completed",
              completedAt: Date.now(),
            });
          }
        }

        return { success: true };
      },
    });
    ```
  </action>
  <verify>
    `bun run lint` passes. All enrollment and completion mutations export correctly.
  </verify>
  <done>
    Enrollment, unenrollment, manual completion, and attendance tracking mutations created with capacity checks and auto-completion logic.
  </done>
</task>

</tasks>

<verification>
1. `bun run lint` passes
2. `bun run dev:convex` starts without errors (schema applies)
3. Schema tables appear in Convex dashboard
4. Test create/update/delete program mutations
5. Test enroll/unenroll member mutations
6. Test manual completion and attendance updates
</verification>

<success_criteria>
- programs and programParticipation tables in schema
- All indexes created for efficient queries
- CRUD mutations work with admin auth
- Enrollment respects capacity limits
- Manual completion and attendance tracking work
- Auto-completion triggers when criteria met
</success_criteria>

<output>
After completion, create `.planning/phases/16-crm-dashboard-programs/16-04-SUMMARY.md`
</output>
