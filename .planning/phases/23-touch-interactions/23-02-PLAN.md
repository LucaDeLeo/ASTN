---
phase: 23-touch-interactions
plan: 02
type: execute
wave: 2
depends_on: [23-01]
files_modified:
  - src/hooks/use-pull-to-refresh.ts
  - src/components/ui/pull-to-refresh.tsx
  - src/routes/matches/index.tsx
  - src/routes/opportunities/index.tsx
autonomous: true

must_haves:
  truths:
    - "User can pull down on matches list to trigger match recomputation"
    - "User can pull down on opportunities list and see refresh indicator"
    - "Pull-to-refresh shows visual feedback during pull and refresh"
    - "Native browser pull-to-refresh is suppressed in pull containers"
  artifacts:
    - path: "src/hooks/use-pull-to-refresh.ts"
      provides: "Pull-to-refresh gesture detection hook"
      exports: ["usePullToRefresh"]
    - path: "src/components/ui/pull-to-refresh.tsx"
      provides: "Pull-to-refresh wrapper component with indicator"
      exports: ["PullToRefresh"]
    - path: "src/routes/matches/index.tsx"
      provides: "Matches list with pull-to-refresh"
      contains: "PullToRefresh"
    - path: "src/routes/opportunities/index.tsx"
      provides: "Opportunities list with pull-to-refresh"
      contains: "PullToRefresh"
  key_links:
    - from: "src/hooks/use-pull-to-refresh.ts"
      to: "@use-gesture/react"
      via: "useDrag import"
      pattern: "import.*useDrag.*from.*@use-gesture"
    - from: "src/components/ui/pull-to-refresh.tsx"
      to: "src/hooks/use-pull-to-refresh.ts"
      via: "hook import"
      pattern: "import.*usePullToRefresh"
    - from: "src/routes/matches/index.tsx"
      to: "triggerMatchComputation"
      via: "PullToRefresh onRefresh"
      pattern: "onRefresh.*triggerMatchComputation"
---

<objective>
Implement pull-to-refresh for matches and opportunities list views

Purpose: Give users a familiar mobile interaction pattern to manually refresh data. For matches, this triggers recomputation; for opportunities (real-time via Convex), it provides visual acknowledgment.

Output: usePullToRefresh hook, PullToRefresh wrapper component, integration in matches and opportunities routes
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-touch-interactions/23-RESEARCH.md
@.planning/phases/23-touch-interactions/23-01-PLAN.md
@src/routes/matches/index.tsx
@src/routes/opportunities/index.tsx
@src/components/ui/spinner.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePullToRefresh hook</name>
  <files>src/hooks/use-pull-to-refresh.ts</files>
  <action>
Create the pull-to-refresh gesture detection hook using @use-gesture/react.

Create `src/hooks/use-pull-to-refresh.ts`:

```typescript
import { useDrag } from "@use-gesture/react";
import { useState, useCallback, useRef } from "react";

const THRESHOLD = 80; // Pixels to trigger refresh
const MAX_PULL = 120; // Maximum visual pull distance

interface UsePullToRefreshOptions {
  onRefresh: () => Promise<void>;
  /** Whether pull-to-refresh is enabled (default: true) */
  enabled?: boolean;
}

interface UsePullToRefreshReturn {
  /** Bind props to the scrollable container */
  bind: ReturnType<typeof useDrag>;
  /** Current pull distance (0 to MAX_PULL) */
  pullDistance: number;
  /** Whether currently refreshing */
  isRefreshing: boolean;
  /** Whether pull has passed threshold */
  isTriggered: boolean;
}

export function usePullToRefresh({
  onRefresh,
  enabled = true,
}: UsePullToRefreshOptions): UsePullToRefreshReturn {
  const [pullDistance, setPullDistance] = useState(0);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const containerRef = useRef<HTMLElement | null>(null);

  const handleRefresh = useCallback(async () => {
    setIsRefreshing(true);
    try {
      await onRefresh();
    } finally {
      setIsRefreshing(false);
      setPullDistance(0);
    }
  }, [onRefresh]);

  const bind = useDrag(
    ({ movement: [, my], last, cancel, event }) => {
      if (!enabled || isRefreshing) {
        cancel();
        return;
      }

      // Get the target element to check scroll position
      const target = event?.target as HTMLElement;
      const scrollContainer = target?.closest("[data-pull-to-refresh]");
      const scrollTop = scrollContainer?.scrollTop ?? 0;

      // Only allow pull when at top of scroll
      if (scrollTop > 0 && my > 0) {
        cancel();
        return;
      }

      // Only allow downward pull
      if (my < 0) {
        setPullDistance(0);
        return;
      }

      // Apply rubber-band effect (diminishing returns past threshold)
      const rubberBand = my > THRESHOLD
        ? THRESHOLD + (my - THRESHOLD) * 0.3
        : my;
      const clampedDistance = Math.min(rubberBand, MAX_PULL);
      setPullDistance(clampedDistance);

      if (last) {
        if (my >= THRESHOLD) {
          handleRefresh();
        } else {
          setPullDistance(0);
        }
      }
    },
    {
      axis: "y",
      filterTaps: true,
      pointer: { touch: true },
    }
  );

  return {
    bind,
    pullDistance,
    isRefreshing,
    isTriggered: pullDistance >= THRESHOLD,
  };
}
```

Key design decisions:
- THRESHOLD of 80px feels natural on mobile
- Rubber-band effect past threshold prevents jarring stop
- Check scrollTop to only activate at top of scroll container
- filterTaps prevents accidental triggers from taps
- pointer: { touch: true } optimizes for touch devices
  </action>
  <verify>
```bash
grep -l "export function usePullToRefresh" src/hooks/use-pull-to-refresh.ts
```
  </verify>
  <done>usePullToRefresh hook exists with bind, pullDistance, isRefreshing, isTriggered return values</done>
</task>

<task type="auto">
  <name>Task 2: Create PullToRefresh component</name>
  <files>src/components/ui/pull-to-refresh.tsx</files>
  <action>
Create a wrapper component that provides pull-to-refresh UI around scrollable content.

Create `src/components/ui/pull-to-refresh.tsx`:

```typescript
import { type ReactNode } from "react";
import { usePullToRefresh } from "~/hooks/use-pull-to-refresh";
import { Spinner } from "~/components/ui/spinner";
import { cn } from "~/lib/utils";

interface PullToRefreshProps {
  children: ReactNode;
  onRefresh: () => Promise<void>;
  /** Whether pull-to-refresh is enabled (default: true) */
  enabled?: boolean;
  /** Additional class names for the container */
  className?: string;
}

export function PullToRefresh({
  children,
  onRefresh,
  enabled = true,
  className,
}: PullToRefreshProps) {
  const { bind, pullDistance, isRefreshing, isTriggered } = usePullToRefresh({
    onRefresh,
    enabled,
  });

  // Calculate indicator opacity and transform
  const indicatorOpacity = Math.min(pullDistance / 60, 1);
  const indicatorTransform = `translateY(${Math.min(pullDistance - 40, 20)}px)`;

  return (
    <div
      {...bind()}
      data-pull-to-refresh
      className={cn(
        "relative overflow-y-auto overscroll-y-contain",
        className
      )}
      style={{ touchAction: "pan-y" }}
    >
      {/* Pull indicator */}
      <div
        className={cn(
          "absolute left-1/2 -translate-x-1/2 z-10 pointer-events-none",
          "transition-opacity duration-150",
          pullDistance > 0 || isRefreshing ? "opacity-100" : "opacity-0"
        )}
        style={{
          top: "8px",
          opacity: isRefreshing ? 1 : indicatorOpacity,
          transform: isRefreshing ? "translateY(0)" : indicatorTransform,
        }}
      >
        <div
          className={cn(
            "flex items-center justify-center",
            "w-10 h-10 rounded-full",
            "bg-background/95 backdrop-blur-sm",
            "border border-border shadow-warm-sm",
            isTriggered || isRefreshing ? "text-primary" : "text-muted-foreground"
          )}
        >
          {isRefreshing ? (
            <Spinner className="size-5" />
          ) : (
            <svg
              className={cn(
                "size-5 transition-transform duration-150",
                isTriggered ? "rotate-180" : "rotate-0"
              )}
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
            >
              <path d="M12 5v14M5 12l7-7 7 7" />
            </svg>
          )}
        </div>
      </div>

      {/* Content with pull offset */}
      <div
        style={{
          transform: isRefreshing
            ? "translateY(48px)"
            : `translateY(${pullDistance * 0.5}px)`,
          transition: pullDistance === 0 && !isRefreshing
            ? "transform 200ms ease-out"
            : "none",
        }}
      >
        {children}
      </div>
    </div>
  );
}
```

Key design decisions:
- data-pull-to-refresh attribute for scroll detection in hook
- overscroll-y-contain prevents native refresh conflict
- Arrow icon rotates to down arrow when threshold reached
- Content moves at 0.5x pull distance for natural feel
- Smooth spring-back animation when released below threshold
- Uses existing Spinner component for consistency
  </action>
  <verify>
```bash
grep -l "export function PullToRefresh" src/components/ui/pull-to-refresh.tsx
```
  </verify>
  <done>PullToRefresh component exists with indicator showing pull progress and refreshing state</done>
</task>

<task type="auto">
  <name>Task 3: Integrate pull-to-refresh into routes</name>
  <files>src/routes/matches/index.tsx, src/routes/opportunities/index.tsx</files>
  <action>
Add pull-to-refresh to matches and opportunities list views. Only enable on mobile since desktop has the refresh button.

**In `src/routes/matches/index.tsx`:**

1. Import PullToRefresh and useIsMobile (already imported):
```typescript
import { PullToRefresh } from "~/components/ui/pull-to-refresh";
```

2. In MatchesContent, wrap the main element content with PullToRefresh (after the header div, around the content that can be pulled):

Replace the return statement's main element structure. The key changes:
- Wrap content area in PullToRefresh on mobile
- onRefresh calls handleCompute (which triggers triggerMatchComputation)
- Keep header outside PullToRefresh so it stays fixed

The return JSX for the hasMatches case should look like:
```tsx
return (
  <main className="container mx-auto px-4 py-8">
    <div className="max-w-6xl mx-auto">
      {/* Header stays outside PullToRefresh */}
      <div className="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4 mb-6">
        {/* ... existing header content ... */}
      </div>

      <PullToRefresh
        onRefresh={handleCompute}
        enabled={!isComputing}
        className="min-h-[200px]"
      >
        {/* No matches state or Match sections */}
        {!hasMatches ? (
          /* ... existing no matches card ... */
        ) : (
          <>
            <MatchTierSection tier="great" matches={matches.great} />
            <MatchTierSection tier="good" matches={matches.good} />
            <MatchTierSection tier="exploring" matches={matches.exploring} />
            {growthAreas.length > 0 && (
              <div className="mt-8">
                <GrowthAreas areas={growthAreas} />
              </div>
            )}
          </>
        )}
      </PullToRefresh>
    </div>
  </main>
);
```

Note: handleCompute is async and returns Promise<void>, which matches PullToRefresh's onRefresh signature.

**In `src/routes/opportunities/index.tsx`:**

1. Import PullToRefresh:
```typescript
import { PullToRefresh } from "~/components/ui/pull-to-refresh";
```

2. Create a refresh handler. Since Convex is real-time, we don't need to actually refetch. Just provide visual feedback with a short delay:
```typescript
const handlePullRefresh = useCallback(async () => {
  // Convex is real-time, so data is already fresh
  // This provides visual feedback acknowledging the gesture
  await new Promise((resolve) => setTimeout(resolve, 500));
}, []);
```

3. Wrap the OpportunityList area in PullToRefresh:
```tsx
<PullToRefresh
  onRefresh={handlePullRefresh}
  className="min-h-[200px]"
>
  <OpportunityList
    opportunities={results}
    isLoading={isLoading}
    status={status}
    onLoadMore={() => loadMore(PAGE_SIZE)}
  />
</PullToRefresh>
```

Add useCallback to imports from React.
  </action>
  <verify>
```bash
grep -l "PullToRefresh" src/routes/matches/index.tsx src/routes/opportunities/index.tsx
```
Should show both files contain PullToRefresh.
  </verify>
  <done>Both matches and opportunities routes have PullToRefresh wrapper around their list content</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build passes:**
   ```bash
   bun run lint
   ```

2. **Pull-to-refresh in matches:**
   - Open /matches on mobile viewport
   - Pull down from top of content
   - Should see indicator appear, rotate when threshold reached
   - Release to trigger refresh (spinner shows)

3. **Pull-to-refresh in opportunities:**
   - Open /opportunities on mobile viewport
   - Pull down from top of content
   - Should see indicator, brief refresh animation

4. **Desktop unaffected:**
   - Pull-to-refresh only enables on touch devices
   - Desktop refresh button still works
</verification>

<success_criteria>
- usePullToRefresh hook detects pull gesture and manages refresh state
- PullToRefresh component shows indicator during pull with threshold feedback
- Matches route triggers triggerMatchComputation on pull-to-refresh
- Opportunities route shows visual acknowledgment on pull-to-refresh
- Native browser pull-to-refresh suppressed via overscroll-behavior-y: contain
- Build passes with no lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/23-touch-interactions/23-02-SUMMARY.md`
</output>
