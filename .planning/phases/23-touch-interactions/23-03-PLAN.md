---
phase: 23-touch-interactions
plan: 03
type: execute
wave: 2
depends_on: [23-01]
files_modified:
  - src/components/gestures/swipeable-card.tsx
  - src/components/matches/MatchTierSection.tsx
  - convex/matches.ts
  - convex/schema.ts
autonomous: false

must_haves:
  truths:
    - "User can swipe left on match card to dismiss it"
    - "User can swipe right on match card to save it"
    - "Dismissed matches no longer appear in match list"
    - "Saved matches are visually distinguished"
    - "Swipe gestures show visual feedback during drag"
  artifacts:
    - path: "src/components/gestures/swipeable-card.tsx"
      provides: "Swipeable wrapper component with left/right actions"
      exports: ["SwipeableCard"]
    - path: "convex/matches.ts"
      provides: "Backend mutations for dismiss and save"
      exports: ["dismissMatch", "saveMatch"]
    - path: "convex/schema.ts"
      provides: "Match status field for dismissed/saved tracking"
      contains: "status"
  key_links:
    - from: "src/components/gestures/swipeable-card.tsx"
      to: "@use-gesture/react"
      via: "useDrag import"
      pattern: "import.*useDrag.*from.*@use-gesture"
    - from: "src/components/matches/MatchTierSection.tsx"
      to: "SwipeableCard"
      via: "wrapper around MatchCard"
      pattern: "SwipeableCard.*MatchCard"
    - from: "SwipeableCard onSwipeLeft"
      to: "convex/matches.ts dismissMatch"
      via: "mutation call"
      pattern: "dismissMatch"
---

<objective>
Implement swipe gestures for match cards to dismiss or save opportunities

Purpose: Allow users to quickly triage matches with natural swipe gestures. Swipe left dismisses (removes from list), swipe right saves (marks as favorite). Enhances mobile UX for the core matching feature.

Output: SwipeableCard component, backend dismiss/save mutations, integration in MatchTierSection
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-touch-interactions/23-RESEARCH.md
@.planning/phases/23-touch-interactions/23-01-PLAN.md
@src/components/matches/MatchCard.tsx
@src/components/matches/MatchTierSection.tsx
@convex/matches.ts
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add match status to schema and create mutations</name>
  <files>convex/schema.ts, convex/matches.ts</files>
  <action>
Add status tracking to matches and create dismiss/save mutations.

**In `convex/schema.ts`:**

Find the matches table and add a status field:
```typescript
matches: defineTable({
  // ... existing fields ...
  status: v.optional(v.union(v.literal("active"), v.literal("dismissed"), v.literal("saved"))),
})
```

The status field is optional to maintain backward compatibility with existing matches. Default behavior treats undefined/null as "active".

**In `convex/matches.ts`:**

Add two new mutations at the end of the file:

```typescript
/**
 * Dismiss a match - removes it from the user's match list
 */
export const dismissMatch = mutation({
  args: { matchId: v.id("matches") },
  handler: async (ctx, { matchId }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    const match = await ctx.db.get(matchId);
    if (!match) throw new Error("Match not found");

    // Verify ownership
    const profile = await ctx.db
      .query("profiles")
      .withIndex("by_user_id", (q) => q.eq("userId", identity.subject))
      .unique();
    if (!profile || match.profileId !== profile._id) {
      throw new Error("Not authorized");
    }

    await ctx.db.patch(matchId, { status: "dismissed" });
  },
});

/**
 * Save a match - marks it as a favorite for easy access
 */
export const saveMatch = mutation({
  args: { matchId: v.id("matches") },
  handler: async (ctx, { matchId }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    const match = await ctx.db.get(matchId);
    if (!match) throw new Error("Match not found");

    // Verify ownership
    const profile = await ctx.db
      .query("profiles")
      .withIndex("by_user_id", (q) => q.eq("userId", identity.subject))
      .unique();
    if (!profile || match.profileId !== profile._id) {
      throw new Error("Not authorized");
    }

    await ctx.db.patch(matchId, { status: "saved" });
  },
});
```

Also update the `getMyMatches` query to filter out dismissed matches. Find where matches are grouped by tier and add a filter:

```typescript
// Filter out dismissed matches
const activeMatches = matchesWithOpportunities.filter(
  (m) => m.status !== "dismissed"
);
```

Then use `activeMatches` instead of `matchesWithOpportunities` when grouping by tier.
  </action>
  <verify>
```bash
# Check schema has status field
grep -A5 "matches:" convex/schema.ts | grep "status"

# Check mutations exist
grep "export const dismissMatch" convex/matches.ts
grep "export const saveMatch" convex/matches.ts
```
  </verify>
  <done>Schema has status field on matches table, dismissMatch and saveMatch mutations exist, getMyMatches filters dismissed matches</done>
</task>

<task type="auto">
  <name>Task 2: Create SwipeableCard component</name>
  <files>src/components/gestures/swipeable-card.tsx</files>
  <action>
Create the swipeable card wrapper using @use-gesture/react.

Create the gestures directory if needed:
```bash
mkdir -p src/components/gestures
```

Create `src/components/gestures/swipeable-card.tsx`:

```typescript
import { useDrag } from "@use-gesture/react";
import { useState, type ReactNode } from "react";
import { cn } from "~/lib/utils";
import { useHaptic } from "~/hooks/use-haptic";
import { Check, X } from "lucide-react";

const SWIPE_THRESHOLD = 100; // Pixels to trigger action
const SWIPE_VELOCITY = 0.5; // Min velocity to trigger

interface SwipeableCardProps {
  children: ReactNode;
  onSwipeLeft?: () => void;
  onSwipeRight?: () => void;
  /** Whether swipe is enabled (default: true) */
  enabled?: boolean;
  /** Additional class names */
  className?: string;
}

export function SwipeableCard({
  children,
  onSwipeLeft,
  onSwipeRight,
  enabled = true,
  className,
}: SwipeableCardProps) {
  const [offset, setOffset] = useState(0);
  const [isAnimatingOut, setIsAnimatingOut] = useState<"left" | "right" | null>(null);
  const haptic = useHaptic();

  const bind = useDrag(
    ({ movement: [mx], velocity: [vx], direction: [dx], last, cancel }) => {
      if (!enabled || isAnimatingOut) {
        cancel();
        return;
      }

      if (last) {
        const shouldTrigger =
          Math.abs(mx) > SWIPE_THRESHOLD ||
          (Math.abs(vx) > SWIPE_VELOCITY && Math.abs(mx) > 50);

        if (shouldTrigger) {
          const direction = mx < 0 ? "left" : "right";
          setIsAnimatingOut(direction);
          haptic.tap();

          // Animate out then trigger callback
          setTimeout(() => {
            if (direction === "left" && onSwipeLeft) {
              onSwipeLeft();
            } else if (direction === "right" && onSwipeRight) {
              onSwipeRight();
            }
            setIsAnimatingOut(null);
            setOffset(0);
          }, 200);
        } else {
          setOffset(0);
        }
      } else {
        // Apply some resistance at the edges
        const resistance = Math.abs(mx) > SWIPE_THRESHOLD ? 0.5 : 1;
        setOffset(mx * resistance);
      }
    },
    {
      axis: "x",
      filterTaps: true,
      pointer: { touch: true },
    }
  );

  // Calculate action indicator opacity
  const leftOpacity = Math.min(Math.abs(Math.min(offset, 0)) / SWIPE_THRESHOLD, 1);
  const rightOpacity = Math.min(Math.max(offset, 0) / SWIPE_THRESHOLD, 1);

  // Determine final position for animation
  const translateX = isAnimatingOut
    ? isAnimatingOut === "left" ? -400 : 400
    : offset;

  return (
    <div className={cn("relative overflow-hidden", className)}>
      {/* Background action indicators */}
      <div className="absolute inset-0 flex items-center justify-between px-6 pointer-events-none">
        {/* Dismiss indicator (left swipe) */}
        <div
          className={cn(
            "flex items-center justify-center",
            "w-12 h-12 rounded-full",
            "bg-destructive text-white",
            "transition-opacity duration-100"
          )}
          style={{ opacity: leftOpacity }}
        >
          <X className="size-6" />
        </div>

        {/* Save indicator (right swipe) */}
        <div
          className={cn(
            "flex items-center justify-center",
            "w-12 h-12 rounded-full",
            "bg-emerald-500 text-white",
            "transition-opacity duration-100"
          )}
          style={{ opacity: rightOpacity }}
        >
          <Check className="size-6" />
        </div>
      </div>

      {/* Swipeable content */}
      <div
        {...bind()}
        className={cn(
          "relative bg-background",
          isAnimatingOut && "transition-transform duration-200 ease-out"
        )}
        style={{
          transform: `translateX(${translateX}px)`,
          touchAction: "pan-y",
        }}
      >
        {children}
      </div>
    </div>
  );
}
```

Key design decisions:
- SWIPE_THRESHOLD of 100px prevents accidental triggers
- Velocity check allows fast swipes to trigger even with less distance
- Resistance at edges provides feedback that threshold is near
- Background indicators show action that will happen
- Animate out before callback for smooth UX
- touch-action: pan-y allows vertical scroll while capturing horizontal
  </action>
  <verify>
```bash
grep -l "export function SwipeableCard" src/components/gestures/swipeable-card.tsx
```
  </verify>
  <done>SwipeableCard component exists with left/right swipe detection, visual indicators, and haptic feedback</done>
</task>

<task type="auto">
  <name>Task 3: Integrate SwipeableCard into MatchTierSection</name>
  <files>src/components/matches/MatchTierSection.tsx</files>
  <action>
Wrap MatchCard with SwipeableCard on mobile for swipe-to-dismiss and swipe-to-save functionality.

**In `src/components/matches/MatchTierSection.tsx`:**

1. Add imports:
```typescript
import { useMutation } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { SwipeableCard } from "~/components/gestures/swipeable-card";
import { useIsMobile } from "~/hooks/use-media-query";
```

2. Inside the component, add the mutations and mobile detection:
```typescript
const isMobile = useIsMobile();
const dismissMatch = useMutation(api.matches.dismissMatch);
const saveMatch = useMutation(api.matches.saveMatch);
```

3. Update the mapping of matches to wrap with SwipeableCard on mobile:

Find where MatchCard is rendered (likely in a map) and wrap it conditionally:

```tsx
{matches.map((match) => {
  const card = <MatchCard key={match._id} match={match} />;

  if (isMobile) {
    return (
      <SwipeableCard
        key={match._id}
        onSwipeLeft={() => dismissMatch({ matchId: match._id })}
        onSwipeRight={() => saveMatch({ matchId: match._id })}
      >
        {card}
      </SwipeableCard>
    );
  }

  return card;
})}
```

Note: The key should be on the outermost element (SwipeableCard on mobile, MatchCard on desktop).

4. Optionally, add a visual indicator for saved matches. Update the MatchCard to show a small badge or icon when match.status === "saved". This can be done by:
- Checking if `match.status === "saved"` in the MatchCard
- Adding a small heart or bookmark icon next to the tier badge

However, this may require updating the match type definition. If the types don't include status, skip this visual indicator for now - the backend filtering is the key functionality.
  </action>
  <verify>
```bash
# Check SwipeableCard is imported and used
grep "SwipeableCard" src/components/matches/MatchTierSection.tsx

# Check mutations are set up
grep "dismissMatch\|saveMatch" src/components/matches/MatchTierSection.tsx
```
  </verify>
  <done>MatchTierSection wraps MatchCard with SwipeableCard on mobile, connecting swipe left to dismissMatch and swipe right to saveMatch mutations</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Swipe gestures for match cards:
- Swipe left dismisses the match (removes from list)
- Swipe right saves the match (marks as favorite)
- Visual indicators show during swipe
- Haptic feedback on action trigger
  </what-built>
  <how-to-verify>
1. Open the app on a mobile device or mobile simulator
2. Navigate to /matches (you need matches to test - if none, go to /matches and wait for computation or click Refresh)
3. Test swipe gestures:
   - Swipe a card LEFT slowly - should see red X indicator appear
   - Release before threshold - card should spring back
   - Swipe LEFT past threshold - card should animate out and disappear
   - Swipe a card RIGHT - should see green checkmark indicator
   - Release past threshold - card should animate out (saved)
4. Verify dismissed matches don't reappear on page refresh
5. Test on desktop - swipe should NOT be active (no gesture handlers)
  </how-to-verify>
  <resume-signal>Type "approved" if gestures work correctly, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Schema updated:**
   ```bash
   grep "status" convex/schema.ts
   ```

2. **Mutations exist:**
   ```bash
   grep -E "dismissMatch|saveMatch" convex/matches.ts
   ```

3. **Build passes:**
   ```bash
   bun run lint
   ```

4. **Convex types regenerate:**
   ```bash
   bun run dev:convex
   # Wait for types to regenerate
   ```

5. **Manual testing (checkpoint):**
   - Swipe gestures work on mobile
   - Cards animate out on successful swipe
   - Dismissed matches don't reappear
</verification>

<success_criteria>
- matches schema has optional status field (active/dismissed/saved)
- dismissMatch mutation marks match as dismissed
- saveMatch mutation marks match as saved
- getMyMatches filters out dismissed matches
- SwipeableCard component handles drag gestures with visual feedback
- MatchTierSection uses SwipeableCard on mobile only
- Haptic feedback triggers on swipe action
- Human verification confirms gestures feel native
</success_criteria>

<output>
After completion, create `.planning/phases/23-touch-interactions/23-03-SUMMARY.md`
</output>
