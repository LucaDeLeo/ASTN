---
phase: 25-tauri-mobile-native-features
plan: 04
type: execute
wave: 3
depends_on: ['25-02', '25-03']
files_modified:
  - src/lib/tauri/auth.ts
  - src/components/auth/login-card.tsx
  - src/router.tsx
  - convex/authTauri.ts
autonomous: false
user_setup:
  - service: github-oauth
    why: 'GitHub OAuth for Tauri deep link redirect'
    env_vars: []
    dashboard_config:
      - task: "Add astn://auth/callback to GitHub OAuth app's callback URLs"
        location: 'GitHub > Settings > Developer settings > OAuth Apps > ASTN'
  - service: google-oauth
    why: 'Google OAuth for Tauri deep link redirect'
    env_vars: []
    dashboard_config:
      - task: "Add astn://auth/callback to Google OAuth client's authorized redirect URIs"
        location: 'Google Cloud Console > APIs & Services > Credentials > OAuth 2.0 Client IDs'

must_haves:
  truths:
    - 'User can log in with GitHub OAuth in Tauri app via deep link callback'
    - 'User can log in with Google OAuth in Tauri app via deep link callback'
    - 'Password login continues to work in Tauri app'
    - 'Convex client connects successfully in WebView'
  artifacts:
    - path: 'src/lib/tauri/auth.ts'
      provides: 'Deep link OAuth handler for Tauri'
      exports: ['initDeepLinkAuth', 'exchangeOAuthCode', 'setConvexClient']
      min_lines: 60
    - path: 'src/components/auth/login-card.tsx'
      provides: 'Login UI with Tauri-aware OAuth flow'
      contains: 'isTauri'
    - path: 'convex/authTauri.ts'
      provides: 'OAuth code exchange action for Tauri deep links'
      exports: ['exchangeOAuthCode']
      min_lines: 80
  key_links:
    - from: 'src/lib/tauri/auth.ts'
      to: '@tauri-apps/plugin-deep-link'
      via: 'deep link listener'
      pattern: 'onOpenUrl|getCurrent'
    - from: 'src/components/auth/login-card.tsx'
      to: 'src/lib/tauri/auth.ts'
      via: 'OAuth redirect handling'
      pattern: 'openOAuthInBrowser|initDeepLinkAuth'
    - from: 'src/router.tsx'
      to: 'src/lib/tauri/auth.ts'
      via: 'OAuth code exchange callback'
      pattern: 'exchangeOAuthCode'
    - from: 'src/lib/tauri/auth.ts'
      to: 'convex/authTauri.ts'
      via: 'Convex action call'
      pattern: "api\\.authTauri\\.exchangeOAuthCode"
---

<objective>
Implement OAuth authentication via deep links for Tauri mobile apps

Purpose: Enable GitHub and Google OAuth login in the Tauri mobile app by handling OAuth redirects through the custom URL scheme (astn://auth/callback) instead of web redirects, which don't work properly in WebViews.

Output: Working OAuth login flow where the system browser opens for auth, then deep links back to the app with the auth code, completing the login process.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25-tauri-mobile-native-features/25-RESEARCH.md
@.planning/phases/25-tauri-mobile-native-features/25-01-SUMMARY.md
@.planning/phases/25-tauri-mobile-native-features/25-02-SUMMARY.md
@.planning/phases/25-tauri-mobile-native-features/25-03-SUMMARY.md

@src/lib/platform.ts
@src/components/auth/login-card.tsx
@src/router.tsx
@convex/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deep link auth handler</name>
  <files>src/lib/tauri/auth.ts</files>
  <action>
Create src/lib/tauri/auth.ts with OAuth deep link handling:

```typescript
// src/lib/tauri/auth.ts
// Deep link OAuth handler for Tauri mobile apps

import { isTauri } from '../platform'

type AuthCallback = (params: {
  code: string
  state: string
  provider: 'github' | 'google'
}) => void

let authCallbackHandler: AuthCallback | null = null

/**
 * Initialize deep link listener for OAuth callbacks
 * Call this on app startup before any OAuth flow
 */
export async function initDeepLinkAuth(
  onCallback: AuthCallback,
): Promise<void> {
  if (!isTauri()) return

  authCallbackHandler = onCallback

  try {
    const { getCurrent, onOpenUrl } =
      await import('@tauri-apps/plugin-deep-link')

    // Check if app was launched via deep link (cold start)
    const startUrls = await getCurrent()
    if (startUrls && startUrls.length > 0) {
      handleDeepLinkUrl(startUrls[0])
    }

    // Listen for deep links while app is running (warm start)
    await onOpenUrl((urls) => {
      if (urls.length > 0) {
        handleDeepLinkUrl(urls[0])
      }
    })
  } catch (error) {
    console.error('Failed to initialize deep link auth:', error)
  }
}

/**
 * Parse deep link URL and trigger auth callback
 */
function handleDeepLinkUrl(url: string): void {
  if (!authCallbackHandler) {
    console.warn('Deep link received but no auth callback registered')
    return
  }

  try {
    const parsed = new URL(url)

    // Expected format: astn://auth/callback?code=xxx&state=xxx
    if (parsed.hostname !== 'auth' || parsed.pathname !== '/callback') {
      console.log('Deep link not an auth callback:', url)
      return
    }

    const code = parsed.searchParams.get('code')
    const state = parsed.searchParams.get('state')

    if (!code || !state) {
      console.error('Auth callback missing code or state')
      return
    }

    // Determine provider from state or a custom parameter
    // For now, we'll need to track which provider initiated the flow
    const provider = determineProvider(state)

    authCallbackHandler({ code, state, provider })
  } catch (error) {
    console.error('Failed to parse auth deep link:', error)
  }
}

// Provider tracking - store which provider the OAuth flow was started with
let pendingOAuthProvider: 'github' | 'google' | null = null

export function setPendingOAuthProvider(provider: 'github' | 'google'): void {
  pendingOAuthProvider = provider
}

function determineProvider(state: string): 'github' | 'google' {
  // Return the tracked provider, defaulting to github
  return pendingOAuthProvider || 'github'
}

/**
 * Get the OAuth redirect URL for Tauri (deep link) or web
 */
export function getOAuthRedirectUrl(): string {
  if (isTauri()) {
    return 'astn://auth/callback'
  }
  // Web fallback - use the current origin
  return typeof window !== 'undefined'
    ? `${window.location.origin}/api/auth/callback`
    : '/api/auth/callback'
}

/**
 * Open OAuth provider in system browser (for Tauri)
 * This opens the browser outside the WebView for a proper OAuth flow
 */
export async function openOAuthInBrowser(url: string): Promise<void> {
  if (!isTauri()) {
    // Web: just navigate
    window.location.href = url
    return
  }

  try {
    // Use Tauri shell to open in system browser
    const { open } = await import('@tauri-apps/plugin-shell')
    await open(url)
  } catch (error) {
    // Fallback: try window.open
    console.warn(
      'Failed to open with Tauri shell, falling back to window.open:',
      error,
    )
    window.open(url, '_blank')
  }
}
```

Note: This requires adding @tauri-apps/plugin-shell. Run:

```bash
bun add @tauri-apps/plugin-shell
```

And add to Cargo.toml:

```toml
tauri-plugin-shell = "2"
```

And update lib.rs:

```rust
.plugin(tauri_plugin_shell::init())
```

And add permission to capabilities/default.json:

```json
"shell:allow-open"
```

  </action>
  <verify>TypeScript compiles without errors for src/lib/tauri/auth.ts</verify>
  <done>Deep link auth handler created with OAuth URL parsing and browser opening</done>
</task>

<task type="auto">
  <name>Task 2: Integrate OAuth deep links into login flow</name>
  <files>
    src/components/auth/login-card.tsx
    src/router.tsx
  </files>
  <action>
First, update src/router.tsx to initialize deep link auth on app start:

```typescript
// Add at the top of getRouter() function, after creating convexQueryClient:
import { initDeepLinkAuth } from '~/lib/tauri/auth'
import { isTauri } from '~/lib/platform'

// Inside getRouter(), after convexQueryClient.connect(queryClient):
if (typeof window !== 'undefined' && isTauri()) {
  // Initialize deep link auth listener
  initDeepLinkAuth(async ({ code, state, provider }) => {
    console.log('OAuth callback received:', { code, state, provider })
    // The auth callback will be handled by Convex auth
    // We need to trigger the signIn flow with the received code
    // This depends on how @convex-dev/auth handles OAuth callbacks
  })
}
```

Now update src/components/auth/login-card.tsx to handle Tauri OAuth differently.

Find the OAuth button handlers (GitHub and Google sign-in) and modify them:

```typescript
// Add imports at the top
import { isTauri } from '~/lib/platform'
import {
  setPendingOAuthProvider,
  openOAuthInBrowser,
  getOAuthRedirectUrl,
} from '~/lib/tauri/auth'

// In the component, modify the OAuth sign-in handlers:
// For GitHub button onClick:
const handleGitHubSignIn = async () => {
  if (isTauri()) {
    setPendingOAuthProvider('github')
    // Build OAuth URL with our custom redirect
    const redirectUri = encodeURIComponent(getOAuthRedirectUrl())
    // Note: You'll need to get the actual GitHub OAuth client ID from env
    const clientId = import.meta.env.VITE_GITHUB_CLIENT_ID
    if (!clientId) {
      console.error('VITE_GITHUB_CLIENT_ID not set')
      return
    }
    const state = crypto.randomUUID() // Generate state for CSRF protection
    const authUrl = `https://github.com/login/oauth/authorize?client_id=${clientId}&redirect_uri=${redirectUri}&state=${state}&scope=read:user,user:email`
    await openOAuthInBrowser(authUrl)
  } else {
    // Web: use Convex auth's built-in flow
    await signIn('github')
  }
}

// Similar for Google
const handleGoogleSignIn = async () => {
  if (isTauri()) {
    setPendingOAuthProvider('google')
    const redirectUri = encodeURIComponent(getOAuthRedirectUrl())
    const clientId = import.meta.env.VITE_GOOGLE_CLIENT_ID
    if (!clientId) {
      console.error('VITE_GOOGLE_CLIENT_ID not set')
      return
    }
    const state = crypto.randomUUID()
    const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${clientId}&redirect_uri=${redirectUri}&response_type=code&state=${state}&scope=openid%20email%20profile`
    await openOAuthInBrowser(authUrl)
  } else {
    await signIn('google')
  }
}
```

**Important Note:** Task 3 handles the OAuth code exchange. Do NOT add the code exchange logic here - just set up the UI flow.
</action>
<verify>

1. Build compiles without TypeScript errors
2. OAuth buttons exist with isTauri() conditional logic
   </verify>
   <done>Login card handles OAuth differently for Tauri vs web</done>
   </task>

<task type="auto">
  <name>Task 3: Implement OAuth code exchange for Tauri deep links</name>
  <files>
    src/lib/tauri/auth.ts
    convex/authTauri.ts
    src/router.tsx
  </files>
  <action>
This task completes the OAuth flow by exchanging the authorization code for tokens.

**Step 1: Create Convex action for OAuth code exchange**

Create convex/authTauri.ts:

```typescript
'use node'
// convex/authTauri.ts
// OAuth code exchange for Tauri mobile deep links

import { action } from './_generated/server'
import { v } from 'convex/values'

/**
 * Exchange OAuth authorization code for tokens (Tauri mobile flow)
 *
 * This handles the code exchange that @convex-dev/auth normally does
 * internally for web flows. For Tauri deep links, we need to do it manually.
 */
export const exchangeOAuthCode = action({
  args: {
    code: v.string(),
    provider: v.union(v.literal('github'), v.literal('google')),
    redirectUri: v.string(),
  },
  handler: async (ctx, args) => {
    const { code, provider, redirectUri } = args

    if (provider === 'github') {
      return exchangeGitHubCode(code, redirectUri)
    } else if (provider === 'google') {
      return exchangeGoogleCode(code, redirectUri)
    }

    throw new Error(`Unsupported provider: ${provider}`)
  },
})

async function exchangeGitHubCode(code: string, redirectUri: string) {
  const clientId = process.env.AUTH_GITHUB_ID
  const clientSecret = process.env.AUTH_GITHUB_SECRET

  if (!clientId || !clientSecret) {
    throw new Error('GitHub OAuth credentials not configured')
  }

  const response = await fetch('https://github.com/login/oauth/access_token', {
    method: 'POST',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      client_id: clientId,
      client_secret: clientSecret,
      code,
      redirect_uri: redirectUri,
    }),
  })

  if (!response.ok) {
    const error = await response.text()
    throw new Error(`GitHub token exchange failed: ${error}`)
  }

  const data = await response.json()

  if (data.error) {
    throw new Error(
      `GitHub OAuth error: ${data.error_description || data.error}`,
    )
  }

  // Get user info with the access token
  const userResponse = await fetch('https://api.github.com/user', {
    headers: {
      Authorization: `Bearer ${data.access_token}`,
      Accept: 'application/vnd.github.v3+json',
    },
  })

  if (!userResponse.ok) {
    throw new Error('Failed to fetch GitHub user info')
  }

  const user = await userResponse.json()

  // Get user email (may be separate API call if email is private)
  let email = user.email
  if (!email) {
    const emailsResponse = await fetch('https://api.github.com/user/emails', {
      headers: {
        Authorization: `Bearer ${data.access_token}`,
        Accept: 'application/vnd.github.v3+json',
      },
    })
    if (emailsResponse.ok) {
      const emails = await emailsResponse.json()
      const primary = emails.find((e: any) => e.primary)
      email = primary?.email || emails[0]?.email
    }
  }

  return {
    provider: 'github' as const,
    accessToken: data.access_token,
    user: {
      id: String(user.id),
      email,
      name: user.name || user.login,
      image: user.avatar_url,
    },
  }
}

async function exchangeGoogleCode(code: string, redirectUri: string) {
  const clientId = process.env.AUTH_GOOGLE_ID
  const clientSecret = process.env.AUTH_GOOGLE_SECRET

  if (!clientId || !clientSecret) {
    throw new Error('Google OAuth credentials not configured')
  }

  const response = await fetch('https://oauth2.googleapis.com/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: new URLSearchParams({
      client_id: clientId,
      client_secret: clientSecret,
      code,
      redirect_uri: redirectUri,
      grant_type: 'authorization_code',
    }),
  })

  if (!response.ok) {
    const error = await response.text()
    throw new Error(`Google token exchange failed: ${error}`)
  }

  const data = await response.json()

  if (data.error) {
    throw new Error(
      `Google OAuth error: ${data.error_description || data.error}`,
    )
  }

  // Get user info with the access token
  const userResponse = await fetch(
    'https://www.googleapis.com/oauth2/v2/userinfo',
    {
      headers: {
        Authorization: `Bearer ${data.access_token}`,
      },
    },
  )

  if (!userResponse.ok) {
    throw new Error('Failed to fetch Google user info')
  }

  const user = await userResponse.json()

  return {
    provider: 'google' as const,
    accessToken: data.access_token,
    idToken: data.id_token,
    user: {
      id: user.id,
      email: user.email,
      name: user.name,
      image: user.picture,
    },
  }
}
```

**Step 2: Update src/lib/tauri/auth.ts to use code exchange**

Add to src/lib/tauri/auth.ts:

```typescript
import { api } from '../../convex/_generated/api'
import type { ConvexReactClient } from 'convex/react'

let convexClient: ConvexReactClient | null = null

/**
 * Set the Convex client for OAuth code exchange
 * Call this during app initialization
 */
export function setConvexClient(client: ConvexReactClient): void {
  convexClient = client
}

/**
 * Exchange OAuth code for user session via Convex
 */
export async function exchangeOAuthCode(
  code: string,
  state: string,
  provider: 'github' | 'google',
): Promise<{ success: boolean; error?: string }> {
  if (!convexClient) {
    return { success: false, error: 'Convex client not initialized' }
  }

  try {
    const redirectUri = getOAuthRedirectUrl()

    const result = await convexClient.action(api.authTauri.exchangeOAuthCode, {
      code,
      provider,
      redirectUri,
    })

    // Store the OAuth result for use with @convex-dev/auth
    // The signIn function from useAuthActions can accept OAuth tokens
    console.log('OAuth exchange successful:', result.user.email)

    // Return the result - the caller (router.tsx) will complete the sign-in
    return { success: true, ...result }
  } catch (error) {
    console.error('OAuth code exchange failed:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}
```

**Step 3: Update src/router.tsx to complete the OAuth flow**

Update the initDeepLinkAuth callback in router.tsx:

```typescript
// Replace the placeholder callback with full implementation:
if (typeof window !== 'undefined' && isTauri()) {
  // Set the Convex client for OAuth code exchange
  setConvexClient(convexClient)

  // Initialize deep link auth listener
  initDeepLinkAuth(async ({ code, state, provider }) => {
    console.log('OAuth callback received:', { code, state, provider })

    try {
      // Exchange the code for tokens via Convex action
      const result = await exchangeOAuthCode(code, state, provider)

      if (result.success) {
        // Navigate to profile or intended destination
        console.log('OAuth login successful')
        window.location.href = '/profile'
      } else {
        console.error('OAuth login failed:', result.error)
        // Optionally navigate to login with error
        window.location.href = '/login?error=oauth_failed'
      }
    } catch (error) {
      console.error('OAuth callback error:', error)
      window.location.href = '/login?error=oauth_failed'
    }
  })
}
```

Add the import for setConvexClient and exchangeOAuthCode from ~/lib/tauri/auth.

**Note on @convex-dev/auth integration:** The code exchange returns user info but doesn't automatically create a Convex session. To fully integrate:

1. Option A: Use the returned user info to call a Convex mutation that creates/updates the user and returns a session token
2. Option B: Modify the Convex auth config to accept pre-exchanged tokens

For this plan, implement Option A by having exchangeOAuthCode also create/update the user in Convex. The checkpoint will verify if this approach works with @convex-dev/auth's session management.
</action>
<verify>

1. convex/authTauri.ts compiles without errors: `npx convex typecheck`
2. src/lib/tauri/auth.ts exports exchangeOAuthCode and setConvexClient
3. router.tsx imports and calls setConvexClient and exchangeOAuthCode in the deep link callback
   </verify>
   <done>OAuth code exchange implemented - authorization code is exchanged for tokens and user info via Convex action</done>
   </task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>OAuth login flow via deep links for Tauri mobile app</what-built>
  <how-to-verify>
**Before testing, configure OAuth providers:**

1. **GitHub OAuth App:**
   - Go to GitHub > Settings > Developer settings > OAuth Apps
   - Find your ASTN OAuth App (or create one)
   - Add `astn://auth/callback` to Authorization callback URL
   - Note: GitHub allows multiple callback URLs, add this alongside the web URL

2. **Google OAuth Client:**
   - Go to Google Cloud Console > APIs & Services > Credentials
   - Find your OAuth 2.0 Client ID
   - Add `astn://auth/callback` to Authorized redirect URIs
   - You may need to configure "Custom URI scheme" in the client type

3. **Environment Variables:**
   - Ensure VITE_GITHUB_CLIENT_ID is set in .env.local
   - Ensure VITE_GOOGLE_CLIENT_ID is set in .env.local

**Test the flow:**

1. Run `bun tauri ios dev` or `bun tauri android dev`
2. Navigate to the login screen
3. Tap "Continue with GitHub"
4. The system browser should open to GitHub's login page
5. After authorizing, you should be redirected back to the app
6. Check if login completes or if there are errors in the console

**Known Limitations:**

- The OAuth code exchange may not work automatically with Convex auth
- If login doesn't complete, we may need to implement custom token exchange
- Password login should still work as a fallback

**Report:**

- Does the system browser open for OAuth?
- Does the app receive the deep link callback?
- Does login complete successfully?
- Any error messages in the console?
  </how-to-verify>
  <resume-signal>Describe the results of OAuth testing - what worked, what didn't, and any error messages</resume-signal>
  </task>

</tasks>

<verification>
1. src/lib/tauri/auth.ts exports initDeepLinkAuth and getOAuthRedirectUrl
2. Login card has conditional OAuth handling for Tauri
3. Deep link listener is initialized in router.tsx
4. OAuth flow opens system browser (not WebView) for authentication
</verification>

<success_criteria>

- Deep link auth handler listens for astn://auth/callback URLs
- OAuth buttons open system browser in Tauri context
- App receives OAuth callback via deep link
- Password login continues to work in both web and Tauri
- User has tested OAuth flow and reported results
  </success_criteria>

<output>
After completion, create `.planning/phases/25-tauri-mobile-native-features/25-04-SUMMARY.md`

Note: If OAuth code exchange doesn't work with Convex auth, document the findings and create a follow-up task in STATE.md for custom token exchange implementation.
</output>
