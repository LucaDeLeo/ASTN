---
phase: 25-tauri-mobile-native-features
plan: 06
type: execute
wave: 4
depends_on: ["25-04"]
files_modified:
  - src/lib/tauri/push.ts
  - src/lib/tauri/offline.ts
  - convex/push.ts
  - convex/matching/computeMatches.ts
  - src/routes/opportunities/$id.tsx
autonomous: false
user_setup:
  - service: firebase
    why: "Push notifications via FCM (Android) and APNs (iOS via FCM)"
    env_vars:
      - name: FIREBASE_SERVER_KEY
        source: "Firebase Console > Project settings > Cloud Messaging > Server key"
    dashboard_config:
      - task: "Create Firebase project for ASTN"
        location: "https://console.firebase.google.com/"
      - task: "Enable Cloud Messaging in Firebase Console"
        location: "Firebase Console > Project settings > Cloud Messaging"
      - task: "Download google-services.json for Android"
        location: "Firebase Console > Project settings > Your apps > Android"
      - task: "Upload APNs certificate for iOS"
        location: "Firebase Console > Project settings > Cloud Messaging > APNs certificates"

must_haves:
  truths:
    - "User receives push notification when matched with 'great' tier opportunity"
    - "User can browse previously viewed opportunities while offline"
    - "Offline mode clearly indicates limited functionality"
    - "Push notifications deep link to the relevant match"
  artifacts:
    - path: "src/lib/tauri/push.ts"
      provides: "Push notification registration and handling"
      exports: ["initPushNotifications", "requestPushPermission"]
      min_lines: 50
    - path: "src/lib/tauri/offline.ts"
      provides: "Offline cache for opportunities"
      exports: ["cacheOpportunity", "getCachedOpportunity", "isOffline"]
      min_lines: 60
    - path: "convex/push.ts"
      provides: "Backend push notification trigger"
      exports: ["sendPushNotification"]
      min_lines: 40
  key_links:
    - from: "convex/matching/computeMatches.ts"
      to: "convex/push.ts"
      via: "great match trigger"
      pattern: "sendPushNotification"
    - from: "src/lib/tauri/offline.ts"
      to: "IndexedDB"
      via: "opportunity cache"
      pattern: "indexedDB|openDB"
    - from: "src/routes/opportunities/$id.tsx"
      to: "src/lib/tauri/offline.ts"
      via: "cache on view"
      pattern: "cacheOpportunity"
---

<objective>
Implement push notifications for great matches and offline browsing for viewed opportunities

Purpose: Send push notifications when a user matches with a "great" tier opportunity, driving engagement back to the app. Enable offline browsing of previously viewed opportunities so users can reference job details without connectivity.

Output: Working push notification flow from Convex match creation to device notification, plus IndexedDB-based offline cache for opportunity details.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25-tauri-mobile-native-features/25-RESEARCH.md
@.planning/phases/25-tauri-mobile-native-features/25-04-SUMMARY.md

@src/lib/platform.ts
@src/lib/tauri/store.ts
@convex/matching/computeMatches.ts
@convex/schema.ts
@src/routes/opportunities/$id.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create push notification registration and handling</name>
  <files>src/lib/tauri/push.ts</files>
  <action>
**Note:** Push notifications in Tauri mobile use the community plugin `tauri-plugin-remote-push`. First, install it:

```bash
bun add tauri-plugin-remote-push-api
```

Add to Cargo.toml (src-tauri/Cargo.toml):
```toml
tauri-plugin-remote-push = "1"
```

Add to lib.rs:
```rust
.plugin(tauri_plugin_remote_push::init())
```

Add permission to capabilities/default.json:
```json
"remote-push:default"
```

Create src/lib/tauri/push.ts:

```typescript
// src/lib/tauri/push.ts
// Push notification registration and handling for Tauri mobile

import { isTauri } from '../platform'

interface PushNotificationPayload {
  title: string
  body: string
  data?: Record<string, string>
}

type PushTokenCallback = (token: string) => void
type PushNotificationCallback = (notification: PushNotificationPayload) => void

let tokenCallback: PushTokenCallback | null = null
let notificationCallback: PushNotificationCallback | null = null

/**
 * Initialize push notification listeners
 * Call this on app startup
 */
export async function initPushNotifications(
  onToken: PushTokenCallback,
  onNotification: PushNotificationCallback
): Promise<void> {
  if (!isTauri()) return

  tokenCallback = onToken
  notificationCallback = onNotification

  try {
    // Note: The exact API depends on tauri-plugin-remote-push version
    // This is based on documented patterns - may need adjustment
    const push = await import('tauri-plugin-remote-push-api')

    // Listen for push token registration
    push.onTokenReceived((token: string) => {
      console.log('Push token received:', token)
      if (tokenCallback) {
        tokenCallback(token)
      }
    })

    // Listen for incoming notifications
    push.onNotificationReceived((notification: any) => {
      console.log('Push notification received:', notification)
      if (notificationCallback) {
        notificationCallback({
          title: notification.title || 'ASTN',
          body: notification.body || '',
          data: notification.data,
        })
      }
    })

    // Listen for notification taps (user opened notification)
    push.onNotificationOpened((notification: any) => {
      console.log('Push notification opened:', notification)
      handleNotificationTap(notification)
    })
  } catch (error) {
    console.error('Failed to initialize push notifications:', error)
  }
}

/**
 * Request push notification permission and get device token
 */
export async function requestPushPermission(): Promise<string | null> {
  if (!isTauri()) return null

  try {
    const push = await import('tauri-plugin-remote-push-api')

    // Request permission (shows system prompt on iOS)
    const permission = await push.requestPermission()

    if (!permission) {
      console.log('Push notification permission denied')
      return null
    }

    // Get the device token
    const token = await push.getToken()
    console.log('Push token:', token)

    return token
  } catch (error) {
    console.error('Failed to request push permission:', error)
    return null
  }
}

/**
 * Handle notification tap - navigate to relevant content
 */
function handleNotificationTap(notification: any): void {
  const data = notification.data || {}

  // If notification has a matchId, navigate to match details
  if (data.matchId) {
    // Use the router to navigate - this requires access to router instance
    // For now, use window.location as fallback
    window.location.href = `/matches/${data.matchId}`
  }

  // If notification has an opportunityId, navigate to opportunity
  if (data.opportunityId) {
    window.location.href = `/opportunities/${data.opportunityId}`
  }
}

/**
 * Check if push notifications are supported
 */
export async function isPushSupported(): Promise<boolean> {
  if (!isTauri()) return false

  try {
    const push = await import('tauri-plugin-remote-push-api')
    return typeof push.requestPermission === 'function'
  } catch {
    return false
  }
}
```

**Important:** The `tauri-plugin-remote-push-api` package may have a different API structure. Check the actual package documentation and adjust the imports and method calls accordingly. The code above follows common patterns but may need runtime verification.
  </action>
  <verify>TypeScript compiles without errors (may show warnings for unresolved types from community package)</verify>
  <done>Push notification utilities created with token registration and notification handling</done>
</task>

<task type="auto">
  <name>Task 2: Create offline cache for opportunities</name>
  <files>src/lib/tauri/offline.ts</files>
  <action>
Create src/lib/tauri/offline.ts using IndexedDB for offline caching:

```typescript
// src/lib/tauri/offline.ts
// Offline cache for previously viewed opportunities using IndexedDB

import { isTauri } from '../platform'

const DB_NAME = 'astn-offline'
const DB_VERSION = 1
const OPPORTUNITIES_STORE = 'opportunities'

interface CachedOpportunity {
  id: string
  data: any // Opportunity data from Convex
  cachedAt: number
}

let dbPromise: Promise<IDBDatabase> | null = null

/**
 * Open or create the IndexedDB database
 */
function openDatabase(): Promise<IDBDatabase> {
  if (dbPromise) return dbPromise

  dbPromise = new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION)

    request.onerror = () => {
      console.error('Failed to open IndexedDB:', request.error)
      reject(request.error)
    }

    request.onsuccess = () => {
      resolve(request.result)
    }

    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result

      // Create opportunities store with id as key
      if (!db.objectStoreNames.contains(OPPORTUNITIES_STORE)) {
        const store = db.createObjectStore(OPPORTUNITIES_STORE, { keyPath: 'id' })
        store.createIndex('cachedAt', 'cachedAt', { unique: false })
      }
    }
  })

  return dbPromise
}

/**
 * Cache an opportunity for offline access
 */
export async function cacheOpportunity(
  id: string,
  data: any
): Promise<void> {
  try {
    const db = await openDatabase()
    const transaction = db.transaction(OPPORTUNITIES_STORE, 'readwrite')
    const store = transaction.objectStore(OPPORTUNITIES_STORE)

    const cached: CachedOpportunity = {
      id,
      data,
      cachedAt: Date.now(),
    }

    await new Promise<void>((resolve, reject) => {
      const request = store.put(cached)
      request.onsuccess = () => resolve()
      request.onerror = () => reject(request.error)
    })

    // Cleanup old entries (keep last 50)
    await cleanupOldEntries(db)
  } catch (error) {
    console.error('Failed to cache opportunity:', error)
  }
}

/**
 * Get a cached opportunity by ID
 */
export async function getCachedOpportunity(
  id: string
): Promise<any | null> {
  try {
    const db = await openDatabase()
    const transaction = db.transaction(OPPORTUNITIES_STORE, 'readonly')
    const store = transaction.objectStore(OPPORTUNITIES_STORE)

    return new Promise((resolve, reject) => {
      const request = store.get(id)
      request.onsuccess = () => {
        const cached = request.result as CachedOpportunity | undefined
        resolve(cached?.data || null)
      }
      request.onerror = () => reject(request.error)
    })
  } catch (error) {
    console.error('Failed to get cached opportunity:', error)
    return null
  }
}

/**
 * Get all cached opportunities
 */
export async function getAllCachedOpportunities(): Promise<any[]> {
  try {
    const db = await openDatabase()
    const transaction = db.transaction(OPPORTUNITIES_STORE, 'readonly')
    const store = transaction.objectStore(OPPORTUNITIES_STORE)

    return new Promise((resolve, reject) => {
      const request = store.getAll()
      request.onsuccess = () => {
        const cached = request.result as CachedOpportunity[]
        // Sort by cachedAt descending (most recent first)
        cached.sort((a, b) => b.cachedAt - a.cachedAt)
        resolve(cached.map((c) => c.data))
      }
      request.onerror = () => reject(request.error)
    })
  } catch (error) {
    console.error('Failed to get cached opportunities:', error)
    return []
  }
}

/**
 * Remove old entries to keep cache size manageable
 */
async function cleanupOldEntries(db: IDBDatabase, maxEntries = 50): Promise<void> {
  const transaction = db.transaction(OPPORTUNITIES_STORE, 'readwrite')
  const store = transaction.objectStore(OPPORTUNITIES_STORE)
  const index = store.index('cachedAt')

  const entries: CachedOpportunity[] = await new Promise((resolve, reject) => {
    const request = index.getAll()
    request.onsuccess = () => resolve(request.result)
    request.onerror = () => reject(request.error)
  })

  if (entries.length > maxEntries) {
    // Sort by cachedAt ascending (oldest first)
    entries.sort((a, b) => a.cachedAt - b.cachedAt)

    // Delete oldest entries
    const toDelete = entries.slice(0, entries.length - maxEntries)
    for (const entry of toDelete) {
      store.delete(entry.id)
    }
  }
}

/**
 * Check if the app is offline
 */
export function isOffline(): boolean {
  return typeof navigator !== 'undefined' && !navigator.onLine
}

/**
 * Subscribe to online/offline status changes
 */
export function onConnectivityChange(
  callback: (isOnline: boolean) => void
): () => void {
  if (typeof window === 'undefined') return () => {}

  const handleOnline = () => callback(true)
  const handleOffline = () => callback(false)

  window.addEventListener('online', handleOnline)
  window.addEventListener('offline', handleOffline)

  return () => {
    window.removeEventListener('online', handleOnline)
    window.removeEventListener('offline', handleOffline)
  }
}

/**
 * Clear all cached data (for logout)
 */
export async function clearOfflineCache(): Promise<void> {
  try {
    const db = await openDatabase()
    const transaction = db.transaction(OPPORTUNITIES_STORE, 'readwrite')
    const store = transaction.objectStore(OPPORTUNITIES_STORE)
    store.clear()
  } catch (error) {
    console.error('Failed to clear offline cache:', error)
  }
}
```
  </action>
  <verify>TypeScript compiles without errors for src/lib/tauri/offline.ts</verify>
  <done>Offline cache utilities with IndexedDB storage and connectivity detection</done>
</task>

<task type="auto">
  <name>Task 3: Create backend push notification trigger</name>
  <files>convex/push.ts</files>
  <action>
Create convex/push.ts for sending push notifications from the backend:

```typescript
"use node";
// convex/push.ts
// Backend push notification service using FCM

import { action, internalAction } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";

/**
 * Send a push notification to a user's device
 * Uses Firebase Cloud Messaging (FCM) for both iOS and Android
 */
export const sendPushNotification = internalAction({
  args: {
    userId: v.string(),
    title: v.string(),
    body: v.string(),
    data: v.optional(v.record(v.string(), v.string())),
  },
  handler: async (ctx, args) => {
    // Get the user's push token from their profile or a separate tokens table
    // For now, we'll need to store push tokens somewhere
    // This is a placeholder - actual implementation needs token storage

    const fcmServerKey = process.env.FIREBASE_SERVER_KEY;
    if (!fcmServerKey) {
      console.warn("FIREBASE_SERVER_KEY not configured, skipping push notification");
      return { success: false, error: "FCM not configured" };
    }

    // TODO: Query user's push token from database
    // For now, log the notification for debugging
    console.log("Push notification (not sent - need token storage):", {
      userId: args.userId,
      title: args.title,
      body: args.body,
      data: args.data,
    });

    return { success: false, error: "Push token storage not implemented" };

    // Actual FCM sending code (uncomment when token storage is ready):
    /*
    const pushToken = await getUserPushToken(ctx, args.userId);
    if (!pushToken) {
      return { success: false, error: "No push token for user" };
    }

    const response = await fetch("https://fcm.googleapis.com/fcm/send", {
      method: "POST",
      headers: {
        "Authorization": `key=${fcmServerKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        to: pushToken,
        notification: {
          title: args.title,
          body: args.body,
        },
        data: args.data || {},
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      console.error("FCM error:", error);
      return { success: false, error };
    }

    return { success: true };
    */
  },
});

/**
 * Send push notification for a new "great" tier match
 */
export const notifyGreatMatch = internalAction({
  args: {
    userId: v.string(),
    matchId: v.id("matches"),
    opportunityTitle: v.string(),
    organizationName: v.string(),
  },
  handler: async (ctx, args) => {
    return ctx.runAction(internal.push.sendPushNotification, {
      userId: args.userId,
      title: "Great Match Found!",
      body: `${args.opportunityTitle} at ${args.organizationName} looks like a great fit for you.`,
      data: {
        type: "great_match",
        matchId: args.matchId,
      },
    });
  },
});
```

**Note:** This implementation is partial. To complete it, we need:
1. A table or field to store user push tokens (when they register via the app)
2. A mutation to save push tokens from the client

For now, this sets up the structure. The push token storage can be added as a follow-up.

Also, add to convex/schema.ts a field or table for push tokens:

```typescript
// Add to profiles table or create separate table:
// pushTokens: v.optional(v.array(v.object({
//   token: v.string(),
//   platform: v.union(v.literal("ios"), v.literal("android")),
//   createdAt: v.number(),
// }))),
```

This schema change is optional for this plan - document in SUMMARY.md as follow-up work.
  </action>
  <verify>
1. convex/push.ts compiles without errors
2. Functions are exported correctly
  </verify>
  <done>Backend push notification infrastructure with FCM integration skeleton</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Push notification registration and offline caching</what-built>
  <how-to-verify>
**Test offline caching:**

1. Run the app in simulator: `bun tauri ios dev` or `bun tauri android dev`
2. Navigate to an opportunity detail page
3. View a few different opportunities
4. Enable airplane mode on the simulator/emulator
5. Navigate back to a previously viewed opportunity
6. The opportunity should load from cache with an "Offline" indicator

**Test push notifications (partial - token storage not complete):**

Push notification testing requires:
1. Firebase project setup (see user_setup in frontmatter)
2. Push token storage implementation (follow-up work)

For now, verify:
1. The push permission request works on iOS (shows system dialog)
2. Android push registration doesn't crash
3. Check console logs for "Push token received" or errors

**Note:** Full end-to-end push testing will require:
- Schema update for push tokens
- Mutation to save tokens
- Firebase credentials configured in Convex dashboard

**Report:**
- Does offline caching work for viewed opportunities?
- Does the offline indicator show correctly?
- Does push permission request show on iOS?
- Any errors in console for push registration?
  </how-to-verify>
  <resume-signal>Describe the results of offline and push notification testing</resume-signal>
</task>

</tasks>

<verification>
1. src/lib/tauri/push.ts exports initPushNotifications, requestPushPermission
2. src/lib/tauri/offline.ts exports cacheOpportunity, getCachedOpportunity, isOffline
3. convex/push.ts exports sendPushNotification, notifyGreatMatch
4. Offline cache stores and retrieves opportunity data
5. Push notification infrastructure is in place (full testing pending token storage)
</verification>

<success_criteria>
- Push notification utilities handle token registration and notification events
- Offline cache persists viewed opportunities in IndexedDB
- Backend push action can send notifications via FCM (pending token storage)
- Offline indicator shows when app is disconnected
- User has tested offline browsing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/25-tauri-mobile-native-features/25-06-SUMMARY.md`

**Follow-up work to document in STATE.md:**
- Add pushTokens field to profiles schema or create dedicated table
- Create mutation to save push tokens from client
- Integrate push notification trigger into match computation
- Configure Firebase credentials in Convex dashboard
</output>
