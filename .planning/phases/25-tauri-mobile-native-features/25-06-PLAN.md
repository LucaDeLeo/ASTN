---
phase: 25-tauri-mobile-native-features
plan: 06
type: execute
wave: 4
depends_on: ["25-04"]
files_modified:
  - src/lib/tauri/push.ts
  - src/lib/tauri/offline.ts
  - convex/push.ts
  - convex/matching/computeMatches.ts
  - src/routes/opportunities/$id.tsx
autonomous: false
user_setup:
  - service: firebase
    why: "Push notifications via FCM (Android) and APNs (iOS via FCM)"
    env_vars:
      - name: FIREBASE_SERVER_KEY
        source: "Firebase Console > Project settings > Cloud Messaging > Server key"
    dashboard_config:
      - task: "Create Firebase project for ASTN"
        location: "https://console.firebase.google.com/"
      - task: "Enable Cloud Messaging in Firebase Console"
        location: "Firebase Console > Project settings > Cloud Messaging"
      - task: "Download google-services.json for Android"
        location: "Firebase Console > Project settings > Your apps > Android"
      - task: "Upload APNs certificate for iOS"
        location: "Firebase Console > Project settings > Cloud Messaging > APNs certificates"

must_haves:
  truths:
    - "User receives push notification when matched with 'great' tier opportunity"
    - "User can browse previously viewed opportunities while offline"
    - "Offline mode clearly indicates limited functionality"
    - "Push notifications deep link to the relevant match"
  artifacts:
    - path: "src/lib/tauri/push.ts"
      provides: "Push notification registration and handling"
      exports: ["initPushNotifications", "requestPushPermission"]
      min_lines: 50
    - path: "src/lib/tauri/offline.ts"
      provides: "Offline cache for opportunities"
      exports: ["cacheOpportunity", "getCachedOpportunity", "isOffline"]
      min_lines: 60
    - path: "convex/push.ts"
      provides: "Backend push notification trigger"
      exports: ["sendPushNotification"]
      min_lines: 40
  key_links:
    - from: "convex/matching/computeMatches.ts"
      to: "convex/push.ts"
      via: "great match trigger"
      pattern: "notifyGreatMatch|internal\\.push"
    - from: "src/lib/tauri/offline.ts"
      to: "IndexedDB"
      via: "opportunity cache"
      pattern: "indexedDB|openDB"
    - from: "src/routes/opportunities/$id.tsx"
      to: "src/lib/tauri/offline.ts"
      via: "cache on view"
      pattern: "cacheOpportunity"
    - from: "src/routes/opportunities/$id.tsx"
      to: "src/lib/tauri/offline.ts"
      via: "offline indicator"
      pattern: "isOffline"
---

<objective>
Implement push notifications for great matches and offline browsing for viewed opportunities

Purpose: Send push notifications when a user matches with a "great" tier opportunity, driving engagement back to the app. Enable offline browsing of previously viewed opportunities so users can reference job details without connectivity.

Output: Working push notification flow from Convex match creation to device notification, plus IndexedDB-based offline cache for opportunity details.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25-tauri-mobile-native-features/25-RESEARCH.md
@.planning/phases/25-tauri-mobile-native-features/25-04-SUMMARY.md

@src/lib/platform.ts
@src/lib/tauri/store.ts
@convex/matching/computeMatches.ts
@convex/schema.ts
@src/routes/opportunities/$id.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create push notification registration and handling</name>
  <files>src/lib/tauri/push.ts</files>
  <action>
**Note:** Push notifications in Tauri mobile use the community plugin `tauri-plugin-remote-push`. First, install it:

```bash
bun add tauri-plugin-remote-push-api
```

Add to Cargo.toml (src-tauri/Cargo.toml):
```toml
tauri-plugin-remote-push = "1"
```

Add to lib.rs:
```rust
.plugin(tauri_plugin_remote_push::init())
```

Add permission to capabilities/default.json:
```json
"remote-push:default"
```

Create src/lib/tauri/push.ts:

```typescript
// src/lib/tauri/push.ts
// Push notification registration and handling for Tauri mobile

import { isTauri } from '../platform'

interface PushNotificationPayload {
  title: string
  body: string
  data?: Record<string, string>
}

type PushTokenCallback = (token: string) => void
type PushNotificationCallback = (notification: PushNotificationPayload) => void

let tokenCallback: PushTokenCallback | null = null
let notificationCallback: PushNotificationCallback | null = null

/**
 * Initialize push notification listeners
 * Call this on app startup
 */
export async function initPushNotifications(
  onToken: PushTokenCallback,
  onNotification: PushNotificationCallback
): Promise<void> {
  if (!isTauri()) return

  tokenCallback = onToken
  notificationCallback = onNotification

  try {
    // Note: The exact API depends on tauri-plugin-remote-push version
    // This is based on documented patterns - may need adjustment
    const push = await import('tauri-plugin-remote-push-api')

    // Listen for push token registration
    push.onTokenReceived((token: string) => {
      console.log('Push token received:', token)
      if (tokenCallback) {
        tokenCallback(token)
      }
    })

    // Listen for incoming notifications
    push.onNotificationReceived((notification: any) => {
      console.log('Push notification received:', notification)
      if (notificationCallback) {
        notificationCallback({
          title: notification.title || 'ASTN',
          body: notification.body || '',
          data: notification.data,
        })
      }
    })

    // Listen for notification taps (user opened notification)
    push.onNotificationOpened((notification: any) => {
      console.log('Push notification opened:', notification)
      handleNotificationTap(notification)
    })
  } catch (error) {
    console.error('Failed to initialize push notifications:', error)
  }
}

/**
 * Request push notification permission and get device token
 */
export async function requestPushPermission(): Promise<string | null> {
  if (!isTauri()) return null

  try {
    const push = await import('tauri-plugin-remote-push-api')

    // Request permission (shows system prompt on iOS)
    const permission = await push.requestPermission()

    if (!permission) {
      console.log('Push notification permission denied')
      return null
    }

    // Get the device token
    const token = await push.getToken()
    console.log('Push token:', token)

    return token
  } catch (error) {
    console.error('Failed to request push permission:', error)
    return null
  }
}

/**
 * Handle notification tap - navigate to relevant content
 */
function handleNotificationTap(notification: any): void {
  const data = notification.data || {}

  // If notification has a matchId, navigate to match details
  if (data.matchId) {
    // Use the router to navigate - this requires access to router instance
    // For now, use window.location as fallback
    window.location.href = `/matches/${data.matchId}`
  }

  // If notification has an opportunityId, navigate to opportunity
  if (data.opportunityId) {
    window.location.href = `/opportunities/${data.opportunityId}`
  }
}

/**
 * Check if push notifications are supported
 */
export async function isPushSupported(): Promise<boolean> {
  if (!isTauri()) return false

  try {
    const push = await import('tauri-plugin-remote-push-api')
    return typeof push.requestPermission === 'function'
  } catch {
    return false
  }
}
```

**Important:** The `tauri-plugin-remote-push-api` package may have a different API structure. Check the actual package documentation and adjust the imports and method calls accordingly. The code above follows common patterns but may need runtime verification.
  </action>
  <verify>TypeScript compiles without errors (may show warnings for unresolved types from community package)</verify>
  <done>Push notification utilities created with token registration and notification handling</done>
</task>

<task type="auto">
  <name>Task 2: Create offline cache for opportunities</name>
  <files>src/lib/tauri/offline.ts</files>
  <action>
Create src/lib/tauri/offline.ts using IndexedDB for offline caching:

```typescript
// src/lib/tauri/offline.ts
// Offline cache for previously viewed opportunities using IndexedDB

import { isTauri } from '../platform'

const DB_NAME = 'astn-offline'
const DB_VERSION = 1
const OPPORTUNITIES_STORE = 'opportunities'

interface CachedOpportunity {
  id: string
  data: any // Opportunity data from Convex
  cachedAt: number
}

let dbPromise: Promise<IDBDatabase> | null = null

/**
 * Open or create the IndexedDB database
 */
function openDatabase(): Promise<IDBDatabase> {
  if (dbPromise) return dbPromise

  dbPromise = new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION)

    request.onerror = () => {
      console.error('Failed to open IndexedDB:', request.error)
      reject(request.error)
    }

    request.onsuccess = () => {
      resolve(request.result)
    }

    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result

      // Create opportunities store with id as key
      if (!db.objectStoreNames.contains(OPPORTUNITIES_STORE)) {
        const store = db.createObjectStore(OPPORTUNITIES_STORE, { keyPath: 'id' })
        store.createIndex('cachedAt', 'cachedAt', { unique: false })
      }
    }
  })

  return dbPromise
}

/**
 * Cache an opportunity for offline access
 */
export async function cacheOpportunity(
  id: string,
  data: any
): Promise<void> {
  try {
    const db = await openDatabase()
    const transaction = db.transaction(OPPORTUNITIES_STORE, 'readwrite')
    const store = transaction.objectStore(OPPORTUNITIES_STORE)

    const cached: CachedOpportunity = {
      id,
      data,
      cachedAt: Date.now(),
    }

    await new Promise<void>((resolve, reject) => {
      const request = store.put(cached)
      request.onsuccess = () => resolve()
      request.onerror = () => reject(request.error)
    })

    // Cleanup old entries (keep last 50)
    await cleanupOldEntries(db)
  } catch (error) {
    console.error('Failed to cache opportunity:', error)
  }
}

/**
 * Get a cached opportunity by ID
 */
export async function getCachedOpportunity(
  id: string
): Promise<any | null> {
  try {
    const db = await openDatabase()
    const transaction = db.transaction(OPPORTUNITIES_STORE, 'readonly')
    const store = transaction.objectStore(OPPORTUNITIES_STORE)

    return new Promise((resolve, reject) => {
      const request = store.get(id)
      request.onsuccess = () => {
        const cached = request.result as CachedOpportunity | undefined
        resolve(cached?.data || null)
      }
      request.onerror = () => reject(request.error)
    })
  } catch (error) {
    console.error('Failed to get cached opportunity:', error)
    return null
  }
}

/**
 * Get all cached opportunities
 */
export async function getAllCachedOpportunities(): Promise<any[]> {
  try {
    const db = await openDatabase()
    const transaction = db.transaction(OPPORTUNITIES_STORE, 'readonly')
    const store = transaction.objectStore(OPPORTUNITIES_STORE)

    return new Promise((resolve, reject) => {
      const request = store.getAll()
      request.onsuccess = () => {
        const cached = request.result as CachedOpportunity[]
        // Sort by cachedAt descending (most recent first)
        cached.sort((a, b) => b.cachedAt - a.cachedAt)
        resolve(cached.map((c) => c.data))
      }
      request.onerror = () => reject(request.error)
    })
  } catch (error) {
    console.error('Failed to get cached opportunities:', error)
    return []
  }
}

/**
 * Remove old entries to keep cache size manageable
 */
async function cleanupOldEntries(db: IDBDatabase, maxEntries = 50): Promise<void> {
  const transaction = db.transaction(OPPORTUNITIES_STORE, 'readwrite')
  const store = transaction.objectStore(OPPORTUNITIES_STORE)
  const index = store.index('cachedAt')

  const entries: CachedOpportunity[] = await new Promise((resolve, reject) => {
    const request = index.getAll()
    request.onsuccess = () => resolve(request.result)
    request.onerror = () => reject(request.error)
  })

  if (entries.length > maxEntries) {
    // Sort by cachedAt ascending (oldest first)
    entries.sort((a, b) => a.cachedAt - b.cachedAt)

    // Delete oldest entries
    const toDelete = entries.slice(0, entries.length - maxEntries)
    for (const entry of toDelete) {
      store.delete(entry.id)
    }
  }
}

/**
 * Check if the app is offline
 */
export function isOffline(): boolean {
  return typeof navigator !== 'undefined' && !navigator.onLine
}

/**
 * Subscribe to online/offline status changes
 */
export function onConnectivityChange(
  callback: (isOnline: boolean) => void
): () => void {
  if (typeof window === 'undefined') return () => {}

  const handleOnline = () => callback(true)
  const handleOffline = () => callback(false)

  window.addEventListener('online', handleOnline)
  window.addEventListener('offline', handleOffline)

  return () => {
    window.removeEventListener('online', handleOnline)
    window.removeEventListener('offline', handleOffline)
  }
}

/**
 * Clear all cached data (for logout)
 */
export async function clearOfflineCache(): Promise<void> {
  try {
    const db = await openDatabase()
    const transaction = db.transaction(OPPORTUNITIES_STORE, 'readwrite')
    const store = transaction.objectStore(OPPORTUNITIES_STORE)
    store.clear()
  } catch (error) {
    console.error('Failed to clear offline cache:', error)
  }
}
```
  </action>
  <verify>TypeScript compiles without errors for src/lib/tauri/offline.ts</verify>
  <done>Offline cache utilities with IndexedDB storage and connectivity detection</done>
</task>

<task type="auto">
  <name>Task 3: Create backend push notification trigger</name>
  <files>convex/push.ts</files>
  <action>
Create convex/push.ts for sending push notifications from the backend:

```typescript
"use node";
// convex/push.ts
// Backend push notification service using FCM

import { action, internalAction } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";

/**
 * Send a push notification to a user's device
 * Uses Firebase Cloud Messaging (FCM) for both iOS and Android
 */
export const sendPushNotification = internalAction({
  args: {
    userId: v.string(),
    title: v.string(),
    body: v.string(),
    data: v.optional(v.record(v.string(), v.string())),
  },
  handler: async (ctx, args) => {
    // Get the user's push token from their profile or a separate tokens table
    // For now, we'll need to store push tokens somewhere
    // This is a placeholder - actual implementation needs token storage

    const fcmServerKey = process.env.FIREBASE_SERVER_KEY;
    if (!fcmServerKey) {
      console.warn("FIREBASE_SERVER_KEY not configured, skipping push notification");
      return { success: false, error: "FCM not configured" };
    }

    // TODO: Query user's push token from database
    // For now, log the notification for debugging
    console.log("Push notification (not sent - need token storage):", {
      userId: args.userId,
      title: args.title,
      body: args.body,
      data: args.data,
    });

    return { success: false, error: "Push token storage not implemented" };

    // Actual FCM sending code (uncomment when token storage is ready):
    /*
    const pushToken = await getUserPushToken(ctx, args.userId);
    if (!pushToken) {
      return { success: false, error: "No push token for user" };
    }

    const response = await fetch("https://fcm.googleapis.com/fcm/send", {
      method: "POST",
      headers: {
        "Authorization": `key=${fcmServerKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        to: pushToken,
        notification: {
          title: args.title,
          body: args.body,
        },
        data: args.data || {},
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      console.error("FCM error:", error);
      return { success: false, error };
    }

    return { success: true };
    */
  },
});

/**
 * Send push notification for a new "great" tier match
 */
export const notifyGreatMatch = internalAction({
  args: {
    userId: v.string(),
    matchId: v.id("matches"),
    opportunityTitle: v.string(),
    organizationName: v.string(),
  },
  handler: async (ctx, args) => {
    return ctx.runAction(internal.push.sendPushNotification, {
      userId: args.userId,
      title: "Great Match Found!",
      body: `${args.opportunityTitle} at ${args.organizationName} looks like a great fit for you.`,
      data: {
        type: "great_match",
        matchId: args.matchId,
      },
    });
  },
});
```

**Note:** This implementation is partial. To complete it, we need:
1. A table or field to store user push tokens (when they register via the app)
2. A mutation to save push tokens from the client

For now, this sets up the structure. The push token storage can be added as a follow-up.

Also, add to convex/schema.ts a field or table for push tokens:

```typescript
// Add to profiles table or create separate table:
// pushTokens: v.optional(v.array(v.object({
//   token: v.string(),
//   platform: v.union(v.literal("ios"), v.literal("android")),
//   createdAt: v.number(),
// }))),
```

This schema change is optional for this plan - document in SUMMARY.md as follow-up work.
  </action>
  <verify>
1. convex/push.ts compiles without errors
2. Functions are exported correctly
  </verify>
  <done>Backend push notification infrastructure with FCM integration skeleton</done>
</task>

<task type="auto">
  <name>Task 4: Integrate offline cache into opportunity detail route</name>
  <files>src/routes/opportunities/$id.tsx</files>
  <action>
Modify src/routes/opportunities/$id.tsx to cache opportunities when viewed and show offline indicator.

**Step 1: Add imports at the top of the file**

```typescript
import { useEffect, useState } from 'react'
import { cacheOpportunity, getCachedOpportunity, isOffline, onConnectivityChange } from '~/lib/tauri/offline'
import { isTauri } from '~/lib/platform'
```

**Step 2: Add offline state and caching logic in the component**

Inside the component function, add:

```typescript
const [offline, setOffline] = useState(isOffline())
const [cachedData, setCachedData] = useState<any>(null)

// Subscribe to connectivity changes
useEffect(() => {
  if (!isTauri()) return

  const unsubscribe = onConnectivityChange((isOnline) => {
    setOffline(!isOnline)
  })

  return unsubscribe
}, [])

// Cache opportunity when data is loaded
useEffect(() => {
  if (!isTauri()) return
  if (!opportunity) return

  // Cache the opportunity for offline access
  cacheOpportunity(opportunity._id, opportunity)
}, [opportunity])

// Try to load from cache if offline and no data
useEffect(() => {
  if (!isTauri()) return
  if (!offline) return
  if (opportunity) return // Already have data

  const loadCached = async () => {
    const cached = await getCachedOpportunity(opportunityId)
    if (cached) {
      setCachedData(cached)
    }
  }

  loadCached()
}, [offline, opportunity, opportunityId])

// Use cached data if offline and no live data
const displayOpportunity = opportunity || cachedData
```

**Step 3: Add offline indicator to the UI**

Near the top of the component's return JSX (inside the main container), add:

```tsx
{offline && isTauri() && (
  <div className="mb-4 flex items-center gap-2 rounded-lg bg-yellow-50 px-4 py-2 text-sm text-yellow-800 dark:bg-yellow-900/20 dark:text-yellow-200">
    <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M18.364 5.636a9 9 0 010 12.728m0 0l-2.829-2.829m2.829 2.829L21 21M15.536 8.464a5 5 0 010 7.072m0 0l-2.829-2.829m-4.243 2.829a4.978 4.978 0 01-1.414-2.83m-1.414 5.658a9 9 0 01-2.167-9.238m7.824 2.167a1 1 0 111.414 1.414m-1.414-1.414L3 3" />
    </svg>
    <span>You're offline. Showing cached version.</span>
  </div>
)}
```

**Step 4: Handle case when no data available offline**

If `displayOpportunity` is null and we're offline, show an appropriate message:

```tsx
if (!displayOpportunity && offline) {
  return (
    <div className="flex flex-col items-center justify-center py-12">
      <p className="text-muted-foreground">This opportunity hasn't been cached for offline viewing.</p>
      <p className="text-sm text-muted-foreground mt-2">Connect to the internet to view it.</p>
    </div>
  )
}
```

Use `displayOpportunity` instead of `opportunity` throughout the component's render logic when displaying opportunity data.
  </action>
  <verify>
1. TypeScript compiles without errors
2. `grep "cacheOpportunity" src/routes/opportunities/\$id.tsx` finds the import and usage
3. `grep "isOffline" src/routes/opportunities/\$id.tsx` finds offline indicator logic
  </verify>
  <done>Opportunity detail route caches data for offline access and shows offline indicator</done>
</task>

<task type="auto">
  <name>Task 5: Integrate push notification trigger into match computation</name>
  <files>convex/matching/computeMatches.ts</files>
  <action>
Modify convex/matching/computeMatches.ts to trigger push notifications when creating "great" tier matches.

**Step 1: Add import at the top of the file**

```typescript
import { internal } from "../_generated/api";
```

**Step 2: Find where great matches are created/updated**

Look for the logic that creates or updates matches with tier "great". This is typically in a mutation or action that processes match results.

**Step 3: Add push notification trigger after creating great match**

After a match is created/updated with tier "great", add:

```typescript
// Trigger push notification for great match (async, don't await)
if (match.tier === "great") {
  // Get opportunity details for notification
  const opportunity = await ctx.db.get(match.opportunityId);
  if (opportunity) {
    ctx.scheduler.runAfter(0, internal.push.notifyGreatMatch, {
      userId: match.userId,
      matchId: match._id,
      opportunityTitle: opportunity.title,
      organizationName: opportunity.organization || "Unknown Organization",
    });
  }
}
```

**Note:** Use `ctx.scheduler.runAfter(0, ...)` instead of `ctx.runAction` to avoid blocking the match computation. This schedules the notification to run immediately but asynchronously.

**Alternative if computeMatches is a mutation (not action):**

If computeMatches is a mutation, you cannot call actions directly. Instead:

1. Create a separate scheduled function or
2. Use ctx.scheduler to schedule the action:

```typescript
// In a mutation context:
await ctx.scheduler.runAfter(0, internal.push.notifyGreatMatch, {
  userId: match.userId,
  matchId: match._id,
  opportunityTitle: opportunity.title,
  organizationName: opportunity.organization || "Unknown Organization",
});
```

The scheduler approach works from both mutations and actions.
  </action>
  <verify>
1. `npx convex typecheck` passes
2. `grep "notifyGreatMatch" convex/matching/computeMatches.ts` finds the trigger
3. `grep "internal.push" convex/matching/computeMatches.ts` confirms import usage
  </verify>
  <done>Match computation triggers push notification for great tier matches</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Push notification registration and offline caching</what-built>
  <how-to-verify>
**Test offline caching:**

1. Run the app in simulator: `bun tauri ios dev` or `bun tauri android dev`
2. Navigate to an opportunity detail page
3. View a few different opportunities
4. Enable airplane mode on the simulator/emulator
5. Navigate back to a previously viewed opportunity
6. The opportunity should load from cache with an "Offline" indicator

**Test push notifications (partial - token storage not complete):**

Push notification testing requires:
1. Firebase project setup (see user_setup in frontmatter)
2. Push token storage implementation (follow-up work)

For now, verify:
1. The push permission request works on iOS (shows system dialog)
2. Android push registration doesn't crash
3. Check console logs for "Push token received" or errors

**Note:** Full end-to-end push testing will require:
- Schema update for push tokens
- Mutation to save tokens
- Firebase credentials configured in Convex dashboard

**Report:**
- Does offline caching work for viewed opportunities?
- Does the offline indicator show correctly?
- Does push permission request show on iOS?
- Any errors in console for push registration?
  </how-to-verify>
  <resume-signal>Describe the results of offline and push notification testing</resume-signal>
</task>

</tasks>

<verification>
1. src/lib/tauri/push.ts exports initPushNotifications, requestPushPermission
2. src/lib/tauri/offline.ts exports cacheOpportunity, getCachedOpportunity, isOffline
3. convex/push.ts exports sendPushNotification, notifyGreatMatch
4. Offline cache stores and retrieves opportunity data
5. Push notification infrastructure is in place (full testing pending token storage)
</verification>

<success_criteria>
- Push notification utilities handle token registration and notification events
- Offline cache persists viewed opportunities in IndexedDB
- Backend push action can send notifications via FCM (pending token storage)
- Offline indicator shows when app is disconnected
- User has tested offline browsing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/25-tauri-mobile-native-features/25-06-SUMMARY.md`

**Follow-up work to document in STATE.md:**
- Add pushTokens field to profiles schema or create dedicated table
- Create mutation to save push tokens from client
- Integrate push notification trigger into match computation
- Configure Firebase credentials in Convex dashboard
</output>
