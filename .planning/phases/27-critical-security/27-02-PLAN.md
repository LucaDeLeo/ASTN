---
phase: 27-critical-security
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/authTauri.ts
  - src/lib/tauri/auth.ts
  - src/components/auth/oauth-buttons.tsx
  - src/router.tsx
autonomous: true

must_haves:
  truths:
    - 'exchangeOAuthCode rejects redirectUri values not in the hardcoded allowlist'
    - 'Tauri mobile OAuth flow generates a PKCE code_verifier and sends code_challenge with S256 method'
    - 'PKCE code_verifier and state are persisted to Tauri Store (survives app kill), not module-level variables'
    - 'OAuth state parameter generated before redirect is validated on callback'
    - 'Console.log statements in OAuth flow are removed or gated behind a debug flag'
    - 'exchangeOAuthCode passes codeVerifier to GitHub/Google token exchange when provided'
    - 'src/router.tsx deep-link callback retrieves codeVerifier from PKCE store and passes it to exchangeOAuthCode'
    - 'PKCE data is cleared from Tauri Store after successful OAuth exchange'
  artifacts:
    - path: 'convex/authTauri.ts'
      provides: 'Hardened OAuth code exchange with redirectUri allowlist and PKCE support'
      contains: 'ALLOWED_REDIRECT_URIS'
    - path: 'src/lib/tauri/auth.ts'
      provides: 'PKCE generation, Tauri Store persistence for code_verifier/state, state validation on callback'
      contains: 'generateCodeVerifier'
    - path: 'src/components/auth/oauth-buttons.tsx'
      provides: 'OAuth buttons with PKCE code_challenge in auth URLs, no console.log'
      contains: 'code_challenge'
    - path: 'src/router.tsx'
      provides: 'Deep-link callback passing codeVerifier from PKCE store to exchangeOAuthCode'
      contains: 'codeVerifier'
  key_links:
    - from: 'src/components/auth/oauth-buttons.tsx'
      to: 'src/lib/tauri/auth.ts'
      via: 'imports PKCE helpers and store functions'
      pattern: 'generateCode|storePKCE'
    - from: 'src/lib/tauri/auth.ts'
      to: 'convex/authTauri.ts'
      via: 'passes codeVerifier in exchangeOAuthCode action call'
      pattern: 'codeVerifier'
    - from: 'convex/authTauri.ts'
      to: 'GitHub/Google token endpoints'
      via: 'includes code_verifier in token exchange POST body'
      pattern: 'code_verifier'
    - from: 'src/router.tsx'
      to: 'src/lib/tauri/auth.ts'
      via: 'deep-link callback passes codeVerifier from PKCE store to exchangeOAuthCode'
      pattern: 'codeVerifier'
---

<objective>
Harden the OAuth flow with PKCE (S256), state parameter validation, redirectUri allowlist, persistent PKCE storage via Tauri Store, and console.log cleanup.

Purpose: Prevent CSRF attacks via state validation, authorization code interception via PKCE, and open redirect attacks via redirectUri allowlist. Replace fragile module-level state variables with persistent storage that survives mobile app kill.

Output: Hardened OAuth flow across four files -- server-side allowlist and PKCE verification, client-side PKCE generation with persistent storage, cleaned-up OAuth button component, and router deep-link callback passing codeVerifier through to the exchange action.
</objective>

<execution_context>
@/Users/luca/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luca/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-critical-security/27-CONTEXT.md
@.planning/phases/27-critical-security/27-RESEARCH.md

Key source files to read before starting:
@convex/authTauri.ts (server-side OAuth code exchange -- add allowlist + PKCE)
@src/lib/tauri/auth.ts (client-side OAuth helpers -- add PKCE generation + Tauri Store persistence)
@src/components/auth/oauth-buttons.tsx (OAuth UI -- add PKCE params to URLs, remove console.log)
@src/lib/platform.ts (isTauri() helper -- already exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add redirectUri allowlist and PKCE support to server-side OAuth exchange</name>
  <files>convex/authTauri.ts</files>
  <action>
1. Add a redirectUri allowlist constant at the top of the file (after imports):
   ```typescript
   const ALLOWED_REDIRECT_URIS = [
     "astn://auth/callback",                    // Tauri mobile deep link
     // Web callback URLs added via env var for flexibility
   ];
   ```
   Also read `process.env.AUTH_REDIRECT_URI_WEB` and push it to the array if set (allows web callback without hardcoding domain).

2. Modify `exchangeOAuthCode` action:
   - Add `codeVerifier: v.optional(v.string())` to args
   - At the start of handler, validate redirectUri:
     ```typescript
     const webRedirectUri = process.env.AUTH_REDIRECT_URI_WEB
     const allowedUris = [...ALLOWED_REDIRECT_URIS]
     if (webRedirectUri) allowedUris.push(webRedirectUri)
     if (!allowedUris.includes(redirectUri)) {
       throw new Error('Invalid redirect URI')
     }
     ```
   - Pass `codeVerifier` to both `exchangeGitHubCode` and `exchangeGoogleCode` functions

3. Modify `exchangeGitHubCode` function:
   - Add `codeVerifier?: string` parameter
   - If `codeVerifier` is provided, include `code_verifier: codeVerifier` in the POST body to GitHub's token endpoint (GitHub supports PKCE since 2021)

4. Modify `exchangeGoogleCode` function:
   - Add `codeVerifier?: string` parameter
   - If `codeVerifier` is provided, include `code_verifier: codeVerifier` in the URLSearchParams body to Google's token endpoint

5. IMPORTANT anti-pattern to avoid: Do NOT make `exchangeOAuthCode` an internalAction. It must remain a public action because the Tauri client calls it directly.

6. Note on token exposure: The current function returns `accessToken` and `idToken` in the response. Per CONTEXT.md, this is flagged for post-pilot fix but not changed in Phase 27. The focus here is redirectUri validation + PKCE. Add a TODO comment: `// TODO: Post-pilot - stop returning raw tokens to client, handle session server-side`
   </action>
   <verify>
   Run `npx convex dev --once` to verify authTauri.ts compiles. Check:

- ALLOWED_REDIRECT_URIS constant exists
- codeVerifier is optional arg on exchangeOAuthCode
- codeVerifier passed through to exchange functions
- redirectUri validation throws for unlisted URIs
  </verify>
  <done>
- exchangeOAuthCode rejects redirectUri values not in allowlist
- codeVerifier optional arg accepted and forwarded to GitHub/Google token exchange
- Token exchange POST bodies include code_verifier when provided
- Existing functionality preserved (backward compatible -- codeVerifier is optional)
  </done>
  </task>

<task type="auto">
  <name>Task 2: Add PKCE generation, Tauri Store persistence, state validation, and console.log cleanup</name>
  <files>src/lib/tauri/auth.ts, src/components/auth/oauth-buttons.tsx, src/router.tsx</files>
  <action>
1. Modify `src/lib/tauri/auth.ts`:

a. Add PKCE helper functions (do NOT import any new libraries -- use Web Crypto API):

````typescript
function generateCodeVerifier(): string {
const array = new Uint8Array(32);
crypto.getRandomValues(array);
return base64UrlEncode(array);
}

      async function generateCodeChallenge(verifier: string): Promise<string> {
        const encoder = new TextEncoder();
        const data = encoder.encode(verifier);
        const hash = await crypto.subtle.digest("SHA-256", data);
        return base64UrlEncode(new Uint8Array(hash));
      }

      function base64UrlEncode(bytes: Uint8Array): string {
        const base64 = btoa(String.fromCharCode(...bytes));
        return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
      }
      ```

b. Add Tauri Store persistence functions (replace module-level `pendingOAuthProvider` variable):
```typescript
interface PKCEData {
codeVerifier: string;
state: string;
provider: "github" | "google";
timestamp: number;
}

      async function storePKCEData(data: Omit<PKCEData, "timestamp">): Promise<void> {
        const { Store } = await import("@tauri-apps/plugin-store");
        const store = await Store.load("oauth.json");
        await store.set("pkce", { ...data, timestamp: Date.now() });
        await store.save();
      }

      async function getPKCEData(): Promise<PKCEData | null> {
        try {
          const { Store } = await import("@tauri-apps/plugin-store");
          const store = await Store.load("oauth.json");
          const data = await store.get<PKCEData>("pkce");
          if (!data) return null;
          // Expire after 5 minutes
          if (Date.now() - data.timestamp > 5 * 60 * 1000) {
            await store.delete("pkce");
            await store.save();
            return null;
          }
          return data;
        } catch {
          return null;
        }
      }

      async function clearPKCEData(): Promise<void> {
        try {
          const { Store } = await import("@tauri-apps/plugin-store");
          const store = await Store.load("oauth.json");
          await store.delete("pkce");
          await store.save();
        } catch {
          // Ignore cleanup errors
        }
      }
      ```

c. Export new functions needed by oauth-buttons.tsx: - `export { generateCodeVerifier, generateCodeChallenge, storePKCEData, getPKCEData, clearPKCEData }` - Keep existing exports (`initDeepLinkAuth`, `getOAuthRedirectUrl`, `openOAuthInBrowser`, `setConvexClient`)

d. Modify `handleDeepLinkUrl` -- make it `async` and validate state from Tauri Store: - IMPORTANT: `handleDeepLinkUrl` is currently synchronous. It MUST be changed to `async function handleDeepLinkUrl(url: string)` because `getPKCEData()` returns a Promise. - After parsing code and state from URL, call `const storedData = await getPKCEData()` - If no PKCE data found (expired or missing), log error and return - If `storedData.state !== state`, log error "OAuth state mismatch" and return - Use `storedData.provider` instead of `determineProvider()` (which relies on module variable) - Pass `storedData.codeVerifier` to the auth callback (extend AuthCallback type to include optional codeVerifier) - After successful exchange, call `await clearPKCEData()` to clean up stored PKCE data - Update all callers of `handleDeepLinkUrl` to await the result (see step h below)

e. Modify `exchangeOAuthCode` client function to pass `codeVerifier`: - Accept optional `codeVerifier` parameter - Include it in the Convex action call: `{ code, provider, redirectUri, codeVerifier }`

f. Remove the module-level `let pendingOAuthProvider` variable and the `setPendingOAuthProvider` / `determineProvider` functions. Replace with Tauri Store. Keep `setPendingOAuthProvider` export as a no-op or remove it (check if needed by oauth-buttons.tsx -- if so, replace with storePKCEData call).

g. Remove or guard console.log statements: - Remove `console.log('[OAuth] Opened URL with opener plugin')` - Remove any other `console.log("[OAuth]...")` statements in this file - Keep `console.error` statements (those are useful for debugging failures)

h. Modify `src/router.tsx` -- update deep-link callback to pass codeVerifier: - The deep-link callback in `src/router.tsx` (around lines 34-39) calls `handleDeepLinkUrl` and/or calls `exchangeOAuthCode` directly - Since `handleDeepLinkUrl` is now async (step d), update the caller to `await handleDeepLinkUrl(url)` - If the router calls `exchangeOAuthCode` directly (bypassing handleDeepLinkUrl), update it to: 1. Call `getPKCEData()` to retrieve the stored codeVerifier 2. Pass `codeVerifier` in the `exchangeOAuthCode` call: `{ code, provider, redirectUri, codeVerifier: storedData?.codeVerifier }` 3. Call `clearPKCEData()` after successful exchange - Add import for `getPKCEData` and `clearPKCEData` from `~/lib/tauri/auth` if needed - Remove any `console.log("[OAuth]...")` statements in this file

2. Modify `src/components/auth/oauth-buttons.tsx`:

   a. Update imports from `~/lib/tauri/auth`: - Remove `setPendingOAuthProvider` import - Add `generateCodeVerifier`, `generateCodeChallenge`, `storePKCEData` imports

   b. Modify `handleGoogleSignIn` (Tauri branch): - Generate PKCE: `const codeVerifier = generateCodeVerifier()` and `const codeChallenge = await generateCodeChallenge(codeVerifier)` - Generate state: `const state = crypto.randomUUID()` - Store to Tauri Store: `await storePKCEData({ codeVerifier, state, provider: "google" })` - Add PKCE params to auth URL: `&code_challenge=${codeChallenge}&code_challenge_method=S256` - Remove `setPendingOAuthProvider("google")` call

   c. Modify `handleGitHubSignIn` (Tauri branch): - Same PKCE pattern as Google - Generate codeVerifier, codeChallenge, state - Store to Tauri Store - Add PKCE params to auth URL: `&code_challenge=${codeChallenge}&code_challenge_method=S256` - Remove `setPendingOAuthProvider("github")` call - Remove ALL `console.log("[OAuth]...")` statements (lines 50, 56, 63, 64, 65)

   d. Web flow (non-Tauri) remains unchanged -- `signIn("google")` and `signIn("github")` handle their own flow via @convex-dev/auth

   e. Make handlers async if not already (they already are)
   </action>
   <verify>

1. TypeScript check: `bun run lint` passes (or at minimum, `npx tsc --noEmit` on the modified files)
1. Build check: `bun run build` succeeds
1. Verify PKCE flow: In oauth-buttons.tsx, both Google and GitHub Tauri flows include `code_challenge` and `code_challenge_method=S256` in the auth URL
1. Verify no console.log in OAuth flow files: `grep "console.log" src/components/auth/oauth-buttons.tsx src/router.tsx src/lib/tauri/auth.ts` returns nothing
1. Verify Tauri Store usage: `grep "Store.load" src/lib/tauri/auth.ts` returns matches
1. Verify module-level state removed: `grep "let pendingOAuthProvider" src/lib/tauri/auth.ts` returns nothing
   </verify>
   <done>

- OAuth URLs include code_challenge and code_challenge_method=S256 parameters
- PKCE code_verifier persisted to Tauri Store (survives app kill)
- OAuth state parameter stored in Tauri Store and validated on callback
- Module-level pendingOAuthProvider variable eliminated
- Console.log statements removed from OAuth flow (oauth-buttons.tsx, auth.ts, router.tsx)
- codeVerifier passed through to Convex exchangeOAuthCode action
- PKCE data cleared from Tauri Store after successful exchange
- src/router.tsx deep-link callback awaits async handleDeepLinkUrl and passes codeVerifier
- Build succeeds with zero errors
  </done>
  </task>

</tasks>

<verification>
After both tasks complete:

1. Server-side: `npx convex dev --once` succeeds
2. Client-side: `bun run build` succeeds
3. Allowlist: `convex/authTauri.ts` contains `ALLOWED_REDIRECT_URIS` array and validation logic
4. PKCE: Both oauth-buttons.tsx handlers generate code_challenge for Tauri flows
5. Persistence: `src/lib/tauri/auth.ts` uses `@tauri-apps/plugin-store` instead of module variables
6. State validation: `handleDeepLinkUrl` in auth.ts compares callback state against stored state
7. Console cleanup: No `console.log` in `src/components/auth/oauth-buttons.tsx`, `src/router.tsx`, or `src/lib/tauri/auth.ts`
8. Router wiring: `src/router.tsx` deep-link callback passes codeVerifier to exchange and cleans up PKCE data
9. Backward compatibility: Web OAuth flow unchanged (non-Tauri branch untouched)
   </verification>

<success_criteria>

- redirectUri allowlist blocks unauthorized redirect URIs
- PKCE S256 code_challenge included in Tauri OAuth authorization URLs
- code_verifier persisted in Tauri Store and forwarded to server-side token exchange
- OAuth state parameter validated on callback (mismatch rejected)
- No console.log in OAuth flow files (oauth-buttons.tsx, auth.ts, router.tsx)
- PKCE data cleared from Tauri Store after successful exchange (clearPKCEData)
- src/router.tsx deep-link callback passes codeVerifier through to exchangeOAuthCode
- Module-level state variables replaced with persistent Tauri Store
- Web OAuth flow (non-Tauri) unaffected
- Build compiles cleanly
  </success_criteria>

<output>
After completion, create `.planning/phases/27-critical-security/27-02-SUMMARY.md`
</output>
````
