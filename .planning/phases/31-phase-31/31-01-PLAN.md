# Plan 31-01: Schema + Backend — Org Configuration & Co-working Space

## Goal

Add the database schema extensions and Convex functions for org self-configuration (logo, description, social links) and co-working space definition (capacity, operating hours, custom visit fields). This is the foundation that all Phase 31 frontend work depends on.

## Dependencies

- **Phase 30** must be complete (organizations and orgApplications tables exist, org admin auth works)

## Tasks

### Task 1: Extend organizations schema and add coworkingSpaces table

**File:** `convex/schema.ts`

Extend `organizations` table with new optional fields:

```ts
organizations: defineTable({
  // ... existing fields (name, slug, logoUrl, description, city, country, etc.)

  // New fields for Phase 31 self-configuration
  logoStorageId: v.optional(v.id('_storage')), // Convex storage reference for uploaded logo
  contactEmail: v.optional(v.string()),
  website: v.optional(v.string()),
  socialLinks: v.optional(
    v.array(
      v.object({
        platform: v.string(), // "twitter", "linkedin", "github", "discord", etc.
        url: v.string(),
      }),
    ),
  ),
  hasCoworkingSpace: v.optional(v.boolean()), // Denormalized flag for quick checks

  // ... existing indexes unchanged
})
```

Add new `coworkingSpaces` table:

```ts
coworkingSpaces: defineTable({
  orgId: v.id('organizations'),
  name: v.string(), // e.g., "Main Co-working Space"
  capacity: v.number(), // Max people per day
  timezone: v.string(), // IANA timezone, e.g., "America/Argentina/Buenos_Aires"

  // Operating hours: array of 7 objects (0=Sunday through 6=Saturday)
  operatingHours: v.array(
    v.object({
      dayOfWeek: v.number(), // 0-6 (Sunday-Saturday)
      openMinutes: v.number(), // Minutes from midnight (e.g., 540 = 9:00 AM)
      closeMinutes: v.number(), // Minutes from midnight (e.g., 1080 = 6:00 PM)
      isClosed: v.boolean(), // True if closed this day
    }),
  ),

  // Guest access configuration
  guestAccessEnabled: v.boolean(), // Whether guests can apply to visit

  // Custom visit application fields (Phase 33 renders these)
  customVisitFields: v.optional(
    v.array(
      v.object({
        fieldId: v.string(), // Unique ID for this field (e.g., "project", "dietary")
        label: v.string(), // Display label
        type: v.union(
          v.literal('text'),
          v.literal('textarea'),
          v.literal('select'),
          v.literal('checkbox'),
        ),
        required: v.boolean(),
        options: v.optional(v.array(v.string())), // For select type
        placeholder: v.optional(v.string()),
      }),
    ),
  ),

  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index('by_org', ['orgId']),
```

### Task 2: Org profile update mutation

**File:** `convex/orgs/admin.ts`

Add `updateOrgProfile` mutation after the existing `updateLumaConfig` mutation:

```ts
// Update org profile fields (self-configuration)
export const updateOrgProfile = mutation({
  args: {
    orgId: v.id('organizations'),
    description: v.optional(v.string()),
    contactEmail: v.optional(v.string()),
    website: v.optional(v.string()),
    socialLinks: v.optional(
      v.array(
        v.object({
          platform: v.string(),
          url: v.string(),
        }),
      ),
    ),
  },
  handler: async (ctx, { orgId, ...updates }) => {
    await requireOrgAdmin(ctx, orgId)

    const org = await ctx.db.get(orgId)
    if (!org) {
      throw new Error('Organization not found')
    }

    // Build patch object, only including provided fields
    const patch: Record<string, unknown> = {}
    if (updates.description !== undefined) patch.description = updates.description
    if (updates.contactEmail !== undefined) patch.contactEmail = updates.contactEmail
    if (updates.website !== undefined) patch.website = updates.website
    if (updates.socialLinks !== undefined) patch.socialLinks = updates.socialLinks

    if (Object.keys(patch).length > 0) {
      await ctx.db.patch(orgId, patch)
    }

    return { success: true }
  },
})
```

Also add a `getOrgProfile` query for the setup page to load full org data:

```ts
// Get full org profile for admin setup page
export const getOrgProfile = query({
  args: { orgId: v.id('organizations') },
  handler: async (ctx, { orgId }) => {
    await requireOrgAdmin(ctx, orgId)

    const org = await ctx.db.get(orgId)
    if (!org) {
      throw new Error('Organization not found')
    }

    // If logoStorageId exists, resolve the URL
    let resolvedLogoUrl = org.logoUrl ?? null
    if (org.logoStorageId) {
      const url = await ctx.storage.getUrl(org.logoStorageId)
      if (url) resolvedLogoUrl = url
    }

    return {
      ...org,
      resolvedLogoUrl,
    }
  },
})
```

### Task 3: Logo upload mutation

**File:** `convex/orgs/admin.ts`

Add `saveOrgLogo` mutation. Reuses the existing `generateUploadUrl` pattern from `convex/upload.ts` (client calls `generateUploadUrl` first, uploads file, then calls this mutation with the resulting storageId):

```ts
// Save uploaded org logo
export const saveOrgLogo = mutation({
  args: {
    orgId: v.id('organizations'),
    storageId: v.id('_storage'),
  },
  handler: async (ctx, { orgId, storageId }) => {
    await requireOrgAdmin(ctx, orgId)

    const org = await ctx.db.get(orgId)
    if (!org) {
      throw new Error('Organization not found')
    }

    // Delete old logo from storage if it exists
    if (org.logoStorageId) {
      await ctx.storage.delete(org.logoStorageId)
    }

    // Resolve the URL for the new logo
    const logoUrl = await ctx.storage.getUrl(storageId)

    // Update org with new logo
    await ctx.db.patch(orgId, {
      logoStorageId: storageId,
      logoUrl: logoUrl ?? undefined,
    })

    return { success: true, logoUrl }
  },
})

// Remove org logo
export const removeOrgLogo = mutation({
  args: {
    orgId: v.id('organizations'),
  },
  handler: async (ctx, { orgId }) => {
    await requireOrgAdmin(ctx, orgId)

    const org = await ctx.db.get(orgId)
    if (!org) {
      throw new Error('Organization not found')
    }

    // Delete from storage if it exists
    if (org.logoStorageId) {
      await ctx.storage.delete(org.logoStorageId)
    }

    await ctx.db.patch(orgId, {
      logoStorageId: undefined,
      logoUrl: undefined,
    })

    return { success: true }
  },
})
```

### Task 4: Onboarding progress query

**File:** `convex/orgs/admin.ts`

Add `getOnboardingProgress` query. This computes the checklist from org + space data — no separate table:

```ts
// Get onboarding progress for the org (computed from field completeness)
export const getOnboardingProgress = query({
  args: { orgId: v.id('organizations') },
  handler: async (ctx, { orgId }) => {
    await requireOrgAdmin(ctx, orgId)

    const org = await ctx.db.get(orgId)
    if (!org) {
      throw new Error('Organization not found')
    }

    // Check for invite link
    const inviteLinks = await ctx.db
      .query('orgInviteLinks')
      .withIndex('by_org', (q) => q.eq('orgId', orgId))
      .collect()
    const hasActiveInviteLink = inviteLinks.some(
      (link) => !link.expiresAt || link.expiresAt > Date.now(),
    )

    // Check for co-working space
    const space = await ctx.db
      .query('coworkingSpaces')
      .withIndex('by_org', (q) => q.eq('orgId', orgId))
      .first()

    const steps = [
      {
        id: 'logo',
        label: 'Upload organization logo',
        complete: Boolean(org.logoStorageId || org.logoUrl),
        route: 'setup',
      },
      {
        id: 'description',
        label: 'Add organization description',
        complete: Boolean(org.description && org.description.trim().length > 0),
        route: 'setup',
      },
      {
        id: 'contact',
        label: 'Set contact email',
        complete: Boolean(org.contactEmail),
        route: 'setup',
      },
      {
        id: 'invite',
        label: 'Create an invite link for members',
        complete: hasActiveInviteLink,
        route: 'setup',
      },
      {
        id: 'space',
        label: 'Configure co-working space',
        complete: Boolean(space),
        route: 'space',
      },
    ]

    const completedCount = steps.filter((s) => s.complete).length
    const percentage = Math.round((completedCount / steps.length) * 100)

    return {
      steps,
      completedCount,
      totalCount: steps.length,
      percentage,
      isComplete: completedCount === steps.length,
    }
  },
})
```

### Task 5: Co-working space CRUD mutations and queries

**File:** `convex/coworkingSpaces.ts` (new file)

```ts
import { v } from 'convex/values'
import { mutation, query } from './_generated/server'
import { auth } from './auth'
import type { MutationCtx, QueryCtx } from './_generated/server'
import type { Id } from './_generated/dataModel'
```

Helper (inline, same pattern as `convex/orgs/admin.ts`):

```ts
async function requireOrgAdmin(
  ctx: QueryCtx | MutationCtx,
  orgId: Id<'organizations'>,
) {
  const userId = await auth.getUserId(ctx)
  if (!userId) throw new Error('Not authenticated')

  const membership = await ctx.db
    .query('orgMemberships')
    .withIndex('by_user', (q) => q.eq('userId', userId))
    .filter((q) => q.eq(q.field('orgId'), orgId))
    .first()

  if (!membership || membership.role !== 'admin') {
    throw new Error('Admin access required')
  }

  return membership
}
```

**`getSpaceByOrg` (query)** — Get the co-working space for an org (one per org for v1.5):
- Args: `orgId`
- Auth: `requireOrgAdmin`
- Query `coworkingSpaces` with index `by_org`, return first result
- Return null if no space configured

**`createSpace` (mutation)** — Create a co-working space:
- Args: `orgId`, `name`, `capacity`, `timezone`, `operatingHours` (array of 7 day objects), `guestAccessEnabled` (default false)
- Auth: `requireOrgAdmin`
- Validate: no existing space for this org (one per org limit)
- Validate: `operatingHours` has exactly 7 entries, one per day (0-6)
- Validate: `capacity` > 0
- Insert into `coworkingSpaces`
- Patch `organizations` to set `hasCoworkingSpace: true`
- Return the space ID

**`updateSpace` (mutation)** — Update an existing co-working space:
- Args: `spaceId`, optional fields: `name`, `capacity`, `timezone`, `operatingHours`, `guestAccessEnabled`
- Auth: look up space -> orgId -> `requireOrgAdmin`
- Validate capacity > 0 if provided
- Validate operatingHours has 7 entries if provided
- Patch the space, update `updatedAt`

**`deleteSpace` (mutation)** — Delete a co-working space:
- Args: `spaceId`
- Auth: look up space -> orgId -> `requireOrgAdmin`
- Delete the space
- Patch org: `hasCoworkingSpace: false`
- Note: In Phase 32+, this should also handle cleaning up bookings. For now, just delete the space.

**`updateCustomVisitFields` (mutation)** — Update the custom visit application fields:
- Args: `spaceId`, `customVisitFields` (array of field definitions)
- Auth: look up space -> orgId -> `requireOrgAdmin`
- Validate each field has a non-empty `fieldId` and `label`
- Validate `select` type fields have at least one option
- Validate no duplicate `fieldId` values
- Patch the space with the new fields array, update `updatedAt`

```ts
export const updateCustomVisitFields = mutation({
  args: {
    spaceId: v.id('coworkingSpaces'),
    customVisitFields: v.array(
      v.object({
        fieldId: v.string(),
        label: v.string(),
        type: v.union(
          v.literal('text'),
          v.literal('textarea'),
          v.literal('select'),
          v.literal('checkbox'),
        ),
        required: v.boolean(),
        options: v.optional(v.array(v.string())),
        placeholder: v.optional(v.string()),
      }),
    ),
  },
  handler: async (ctx, { spaceId, customVisitFields }) => {
    const space = await ctx.db.get(spaceId)
    if (!space) throw new Error('Space not found')

    await requireOrgAdmin(ctx, space.orgId)

    // Validate fields
    const fieldIds = new Set<string>()
    for (const field of customVisitFields) {
      if (!field.fieldId.trim()) throw new Error('Field ID cannot be empty')
      if (!field.label.trim()) throw new Error('Field label cannot be empty')
      if (fieldIds.has(field.fieldId)) {
        throw new Error(`Duplicate field ID: ${field.fieldId}`)
      }
      fieldIds.add(field.fieldId)

      if (field.type === 'select' && (!field.options || field.options.length === 0)) {
        throw new Error(`Select field "${field.label}" must have at least one option`)
      }
    }

    await ctx.db.patch(spaceId, {
      customVisitFields,
      updatedAt: Date.now(),
    })

    return { success: true }
  },
})
```

### Task 6: Bulk invite query helper

**File:** `convex/orgs/admin.ts`

Add a `getOrCreateInviteLink` mutation that ensures an active invite link exists and returns it. This supports the bulk-invite flow: the frontend lets the admin enter multiple email addresses and then shows the invite link pre-formatted for sharing with those people.

```ts
// Ensure an active invite link exists and return it (for bulk invite flow)
export const getOrCreateInviteLink = mutation({
  args: {
    orgId: v.id('organizations'),
  },
  handler: async (ctx, { orgId }) => {
    const adminMembership = await requireOrgAdmin(ctx, orgId)

    // Check for existing active link
    const existingLinks = await ctx.db
      .query('orgInviteLinks')
      .withIndex('by_org', (q) => q.eq('orgId', orgId))
      .collect()
    const now = Date.now()
    const activeLink = existingLinks.find(
      (link) => !link.expiresAt || link.expiresAt > now,
    )

    if (activeLink) {
      return { token: activeLink.token }
    }

    // Create a new invite link
    const token = crypto.randomUUID()
    await ctx.db.insert('orgInviteLinks', {
      orgId,
      token,
      createdBy: adminMembership._id,
      createdAt: now,
    })

    return { token }
  },
})
```

No email-sending infrastructure exists, so the bulk-invite flow is:
1. Admin enters email addresses in a textarea
2. Frontend calls `getOrCreateInviteLink` to ensure a link exists
3. Frontend generates a pre-formatted message with the invite link
4. Admin copies the message and distributes via their own channels (email, Slack, etc.)

This satisfies ORGON-09 within the constraint of no email service.

## Acceptance Criteria

- [ ] `organizations` table has new optional fields: `logoStorageId`, `contactEmail`, `website`, `socialLinks`, `hasCoworkingSpace`
- [ ] `coworkingSpaces` table exists with capacity, operatingHours (7-day array of minutes-from-midnight), timezone, guestAccessEnabled, customVisitFields
- [ ] `updateOrgProfile` mutation updates org description, contactEmail, website, and socialLinks with admin auth
- [ ] `saveOrgLogo` mutation stores the logo via Convex storage and updates both `logoStorageId` and `logoUrl`
- [ ] `removeOrgLogo` mutation deletes the stored file and clears logo fields
- [ ] `getOnboardingProgress` query returns a computed checklist with 5 steps and completion percentage
- [ ] `createSpace` mutation creates a space with validation (one per org, 7 operating hours entries, capacity > 0)
- [ ] `updateSpace` mutation patches space fields with the same validation
- [ ] `deleteSpace` mutation removes the space and updates the org's `hasCoworkingSpace` flag
- [ ] `updateCustomVisitFields` validates field IDs are unique, labels non-empty, and select fields have options
- [ ] `getOrCreateInviteLink` returns an active invite link token, creating one if none exists
- [ ] All mutations require org admin auth
- [ ] `getOrgProfile` resolves `logoStorageId` to a URL for frontend display
