---
phase: 32-member-booking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/spaceBookings.ts
autonomous: true

must_haves:
  truths:
    - 'A member can create a booking for a specific date with flexible start/end times'
    - 'Booking returns capacity warning (nearing/at_capacity) without blocking'
    - 'A member can cancel their own booking'
    - 'A member can update workingOn/interestedInMeeting tags on their booking'
    - 'A query returns all bookings for a date with consented profile data'
    - "A query returns the user's upcoming bookings"
    - 'Capacity counts only confirmed bookings for the given date'
  artifacts:
    - path: 'convex/schema.ts'
      provides: 'spaceBookings table definition'
      contains: 'spaceBookings: defineTable'
    - path: 'convex/spaceBookings.ts'
      provides: 'Booking mutations and queries'
      exports:
        [
          'createMemberBooking',
          'cancelBooking',
          'updateBookingTags',
          'getBookingsForDate',
          'getMyBookings',
          'getBookingAttendees',
        ]
  key_links:
    - from: 'convex/spaceBookings.ts'
      to: 'convex/schema.ts'
      via: 'spaceBookings table'
      pattern: "ctx\\.db\\.insert\\('spaceBookings'"
    - from: 'convex/spaceBookings.ts'
      to: 'convex/coworkingSpaces.ts'
      via: 'space capacity lookup'
      pattern: "ctx\\.db\\.get\\('coworkingSpaces'"
---

<objective>
Create the spaceBookings table and backend functions for member booking: create booking with soft capacity warnings, cancel booking, update tags, query bookings by date, query user's bookings, and query attendees for a date with consented profile data.

Purpose: This is the data layer for Phase 32 (Member Booking + Consent + Attendee View). Frontend depends on these mutations and queries.

Output:

- Extended schema with spaceBookings table
- New convex/spaceBookings.ts with full CRUD + attendee queries
  </objective>

<execution_context>
@/Users/luca/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luca/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-phase-32/CONTEXT.md

# Prior phase for space schema

@.planning/phases/31-phase-31/31-01-SUMMARY.md

# Existing space functions to follow patterns

@convex/coworkingSpaces.ts
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add spaceBookings table to schema</name>
  <files>convex/schema.ts</files>
  <action>
Add spaceBookings table to the schema after coworkingSpaces:

```typescript
spaceBookings: defineTable({
  spaceId: v.id('coworkingSpaces'),
  userId: v.string(),

  // Date and time
  date: v.string(), // ISO date string e.g. "2026-02-15"
  startMinutes: v.number(), // Minutes from midnight (e.g., 600 = 10:00 AM)
  endMinutes: v.number(), // Minutes from midnight (e.g., 900 = 3:00 PM)

  // Booking type (member now, guest in Phase 33)
  bookingType: v.union(v.literal('member'), v.literal('guest')),

  // Status: members auto-confirm, guests go through approval
  status: v.union(
    v.literal('confirmed'),
    v.literal('cancelled'),
    v.literal('pending'), // For guests (Phase 33)
    v.literal('rejected'), // For guests (Phase 33)
  ),

  // Optional tags
  workingOn: v.optional(v.string()), // Max 140 chars, enforced in mutation
  interestedInMeeting: v.optional(v.string()), // Max 140 chars

  // Consent for attendee visibility (required for booking)
  consentToProfileSharing: v.boolean(),

  // Metadata
  createdAt: v.number(),
  updatedAt: v.number(),
  cancelledAt: v.optional(v.number()),
})
  .index('by_space_date', ['spaceId', 'date'])
  .index('by_user', ['userId'])
  .index('by_space_user', ['spaceId', 'userId'])
```

Also add 'booking_confirmed' to the notifications.type union:

- Find the existing union of notification types
- Add v.literal('booking_confirmed') to it
- Add optional spaceBookingId field: `spaceBookingId: v.optional(v.id('spaceBookings'))`
  </action>
  <verify>Run `bun run dev:convex` briefly to ensure schema compiles without errors. Check Convex dashboard or terminal for schema validation.</verify>
  <done>spaceBookings table exists with all fields and indexes. notifications.type includes 'booking_confirmed'.</done>
  </task>

<task type="auto">
  <name>Task 2: Create spaceBookings.ts with booking mutations</name>
  <files>convex/spaceBookings.ts</files>
  <action>
Create new file convex/spaceBookings.ts with:

**Helper function (copy pattern from coworkingSpaces.ts):**

```typescript
async function requireOrgMember(ctx, spaceId) {
  const userId = await auth.getUserId(ctx)
  if (!userId) throw new Error('Not authenticated')

  const space = await ctx.db.get('coworkingSpaces', spaceId)
  if (!space) throw new Error('Space not found')

  const membership = await ctx.db
    .query('orgMemberships')
    .withIndex('by_user', (q) => q.eq('userId', userId))
    .filter((q) => q.eq(q.field('orgId'), space.orgId))
    .first()

  if (!membership) throw new Error('Not a member of this organization')

  return { userId, space, membership }
}
```

**createMemberBooking mutation:**

- Args: spaceId, date (ISO string), startMinutes, endMinutes, workingOn (optional), interestedInMeeting (optional), consentToProfileSharing (boolean)
- Validate: consentToProfileSharing must be true (reject otherwise with "Consent is required to book")
- Validate: workingOn/interestedInMeeting max 140 chars if provided
- Validate: startMinutes < endMinutes
- Validate: date is a valid ISO date string (YYYY-MM-DD format)
- Check existing bookings for this user on this date (status in ['confirmed', 'pending']) - if exists, throw "You already have a booking for this date"
- Count confirmed bookings for this date: `ctx.db.query('spaceBookings').withIndex('by_space_date', q => q.eq('spaceId', spaceId).eq('date', date)).filter(q => q.eq(q.field('status'), 'confirmed')).collect()`
- Determine capacityWarning: if count >= capacity then 'at_capacity', else if count >= capacity \* 0.8 then 'nearing', else undefined
- Insert booking with bookingType: 'member', status: 'confirmed'
- Return { bookingId, capacityWarning }

**cancelBooking mutation:**

- Args: bookingId
- Get booking, verify user owns it (userId matches)
- Verify status is 'confirmed' (can't cancel already cancelled)
- Patch booking with status: 'cancelled', cancelledAt: Date.now(), updatedAt: Date.now()
- Return { success: true }

**updateBookingTags mutation:**

- Args: bookingId, workingOn (optional), interestedInMeeting (optional)
- Get booking, verify user owns it
- Verify status is 'confirmed' (can't update cancelled booking)
- Validate max 140 chars for each if provided
- Patch booking with the provided fields + updatedAt
- Return { success: true }
  </action>
  <verify>TypeScript compiles: `cd /Users/luca/conductor/workspaces/ASTN/spokane && npx convex dev --once` should succeed.</verify>
  <done>createMemberBooking, cancelBooking, updateBookingTags mutations exist and accept correct arguments.</done>
  </task>

<task type="auto">
  <name>Task 3: Add booking queries to spaceBookings.ts</name>
  <files>convex/spaceBookings.ts</files>
  <action>
Add these queries to convex/spaceBookings.ts:

**getBookingsForDate query:**

- Args: spaceId, date
- Requires org membership (use requireOrgMember helper)
- Query all bookings for spaceId + date (any status for admin visibility, but primarily confirmed)
- Return array of bookings with their data

**getMyBookings query:**

- Args: spaceId
- Gets authenticated user
- Query bookings where userId matches and spaceId matches
- Filter to status in ['confirmed', 'pending'] (exclude cancelled/rejected)
- Sort by date ascending
- Return array of bookings

**getBookingAttendees query:**

- Args: spaceId, date
- Requires org membership (use requireOrgMember)
- Query all bookings for spaceId + date where status = 'confirmed' AND consentToProfileSharing = true
- For each booking, look up profile by userId: `ctx.db.query('profiles').withIndex('by_user', q => q.eq('userId', booking.userId)).first()`
- Return array of: { bookingId, userId, date, startMinutes, endMinutes, workingOn, interestedInMeeting, profile: { name, headline, skills } }
- Only include profile fields: name, headline, skills (this is the "booking profile" subset)
- If profile not found, still include the booking but with null profile

**getCapacityForDateRange query:**

- Args: spaceId, startDate, endDate (both ISO strings)
- Requires org membership
- Get space to retrieve capacity
- Query all confirmed bookings in date range
- Group by date and count
- Return: { capacity: number, dates: { [date: string]: { count: number, status: 'available' | 'nearing' | 'at_capacity' } } }
- Status: 'at_capacity' if count >= capacity, 'nearing' if count >= capacity \* 0.7, else 'available'
- This powers the calendar availability indicators
  </action>
  <verify>Run `npx convex dev --once` to verify all queries compile. Check for TypeScript errors.</verify>
  <done>getBookingsForDate, getMyBookings, getBookingAttendees, getCapacityForDateRange queries exist and return correct data shapes.</done>
  </task>

</tasks>

<verification>
1. Schema compiles: `bun run dev:convex` starts without errors
2. All mutations exist in Convex dashboard Functions tab
3. All queries exist in Convex dashboard Functions tab
4. TypeScript has no errors: `bun run lint` passes
</verification>

<success_criteria>

- spaceBookings table in schema with all fields, indexes
- notifications.type includes 'booking_confirmed'
- createMemberBooking returns { bookingId, capacityWarning? }
- cancelBooking and updateBookingTags work for own bookings
- getMyBookings returns user's upcoming bookings
- getBookingAttendees returns consented profile data only
- getCapacityForDateRange returns capacity status per date
  </success_criteria>

<output>
After completion, create `.planning/phases/32-phase-32/32-01-SUMMARY.md`
</output>
