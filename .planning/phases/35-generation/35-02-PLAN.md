---
phase: 35-generation
plan: 02
type: execute
wave: 2
depends_on: ['35-01']
files_modified:
  - convex/careerActions/prompts.ts
  - convex/careerActions/compute.ts
  - convex/matches.ts
autonomous: true

must_haves:
  truths:
    - 'Claude Haiku 4.5 generates 3-5 personalized career actions spanning at least 3 of 8 types'
    - 'Each generated action includes rationale and profileBasis referencing specific profile elements'
    - 'Action generation triggers alongside match computation via ctx.scheduler.runAfter(0, ...)'
    - 'Preserved actions (saved/in_progress/done) are passed to LLM to avoid duplicate suggestions'
    - 'Generation prompt explicitly forbids naming specific papers, programs, or URLs'
  artifacts:
    - path: 'convex/careerActions/prompts.ts'
      provides: 'System prompt, tool definition, context builders'
      exports:
        [
          'ACTION_GENERATION_SYSTEM_PROMPT',
          'generateCareerActionsTool',
          'buildActionGenerationContext',
        ]
    - path: 'convex/careerActions/compute.ts'
      provides: 'LLM generation action'
      exports: ['computeActionsForProfile']
    - path: 'convex/matches.ts'
      provides: 'Scheduler trigger for action generation'
      contains: 'scheduler.runAfter'
  key_links:
    - from: 'convex/matches.ts'
      to: 'convex/careerActions/compute.ts'
      via: 'ctx.scheduler.runAfter(0, internal.careerActions.compute.computeActionsForProfile)'
      pattern: "scheduler\\.runAfter.*careerActions"
    - from: 'convex/careerActions/compute.ts'
      to: 'convex/careerActions/prompts.ts'
      via: 'tool definition and system prompt import'
      pattern: 'generateCareerActionsTool'
    - from: 'convex/careerActions/compute.ts'
      to: 'convex/careerActions/mutations.ts'
      via: 'ctx.runMutation(internal.careerActions.mutations.saveGeneratedActions)'
      pattern: 'saveGeneratedActions'
---

<objective>
Build the LLM generation pipeline: system prompt with tool definition, Haiku compute action, and trigger wiring into the existing match computation flow.

Purpose: This is the engine that creates personalized career actions -- the core differentiator of v1.6. Without it, the UI shows empty states.
Output: Working Haiku generation pipeline that produces 3-5 personalized actions when matches are refreshed.
</objective>

<execution_context>
@/Users/luca/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luca/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-generation/35-RESEARCH.md
@.planning/phases/35-generation/35-01-SUMMARY.md
@convex/matching/prompts.ts
@convex/matching/compute.ts
@convex/matches.ts
@convex/careerActions/queries.ts
@convex/careerActions/mutations.ts
@convex/careerActions/validation.ts
@convex/lib/logging.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create prompts module with system prompt and tool definition</name>
  <files>convex/careerActions/prompts.ts</files>
  <action>
  Create `convex/careerActions/prompts.ts` following `convex/matching/prompts.ts` pattern.

**Exports:**

1. `ACTION_GENERATION_SYSTEM_PROMPT` — system prompt string. Key instructions:
   - Role: "AI career action advisor for the AI Safety Talent Network"
   - Task: Generate 3-5 personalized, self-directed career actions based on the person's profile
   - Action types: Explain each of the 8 types with a sentence of guidance:
     - `replicate`: Reproduce or extend existing AI safety research
     - `collaborate`: Find and partner with others on AI safety work
     - `start_org`: Launch a new initiative, group, or project
     - `identify_gaps`: Research underexplored problems or areas
     - `volunteer`: Contribute time to existing AI safety organizations
     - `build_tools`: Create software, datasets, or resources for the field
     - `teach_write`: Share knowledge through writing, teaching, or mentoring
     - `develop_skills`: Build specific technical or domain skills
   - Variety requirement: "Generate actions spanning at LEAST 3 different types"
   - Personalization requirement: "Each action MUST reference specific elements from this person's profile — their skills, experience, education, interests, or career goals. Generic advice like 'Learn more about AI safety' is NOT acceptable."
   - Anti-hallucination: "Do NOT reference specific papers, programs, fellowships, organizations, or external resources by name. Describe what the person should LOOK FOR or DO, not specific resources to find."
   - Deduplication: "Do NOT generate actions similar to the preserved actions listed below. The person is already working on those."
   - ProfileBasis: "For each action, list the specific profile signals that drove this recommendation (e.g., 'ML engineering skills', 'interpretability research interest', 'policy background')"
   - Tone: "Encouraging but concrete. Each action should feel achievable within 1-3 months."

2. `generateCareerActionsTool` — Anthropic tool definition (type `Anthropic.Tool`). Follow the exact structure from the research doc:
   - name: `'generate_career_actions'`
   - description: `'Generate personalized career actions for an AI safety professional'`
   - input_schema with `actions` array (minItems 3, maxItems 5), each item has: type (enum of 8), title (5-10 words), description (2-3 sentences), rationale (why this fits THIS person), profileBasis (array of strings, profile elements that drove this)
   - All fields required

3. `buildActionGenerationContext` — function that takes profile context string, growth areas array, and preserved actions array, and returns a single formatted user message string:
   - Section 1: "## Candidate Profile\n\n{profileContext}" — reuse `buildProfileContext()` output from `convex/matching/prompts.ts` (import it)
   - Section 2: "## Growth Areas from Matching\n\n{formatted growth areas}" — bullet list of growth areas. If empty, say "No match data available yet."
   - Section 3: "## Preserved Actions (do not duplicate)\n\n{formatted preserved actions}" — bullet list with type + title. If empty, say "None — this is a first-time generation."

Import `Anthropic` type from `@anthropic-ai/sdk` (type-only import since this file doesn't need `"use node"`).
Import `buildProfileContext` from `../matching/prompts` for reuse.
</action>
<verify>Run `npx convex dev --once` — file should compile without errors. Verify exports are importable from compute.ts.</verify>
<done>System prompt enforces personalization, anti-hallucination, type variety, and deduplication. Tool definition guarantees structured 3-5 action output. Context builder composes profile + growth areas + preserved actions into a single user message.</done>
</task>

<task type="auto">
  <name>Task 2: Create compute action and wire trigger into match computation</name>
  <files>convex/careerActions/compute.ts, convex/matches.ts</files>
  <action>
  1. Create `convex/careerActions/compute.ts` following `convex/matching/compute.ts` pattern:

     - Start with `"use node"` directive
     - Import: `v` from convex/values, `Anthropic` from `@anthropic-ai/sdk`, `internalAction` from `../_generated/server`, `internal` from `../_generated/api`, `log` from `../lib/logging`
     - Import prompt/tool from `./prompts`: `ACTION_GENERATION_SYSTEM_PROMPT`, `generateCareerActionsTool`, `buildActionGenerationContext`
     - Import validation: `actionResultSchema` from `./validation`
     - Import `buildProfileContext` from `../matching/prompts`

     - `MODEL_VERSION = 'claude-haiku-4-5-20251001'` (per locked decision #3)

     - Export `computeActionsForProfile` as `internalAction`:
       - args: `{ profileId: v.id('profiles') }`
       - Handler steps:
         a. Fetch profile via `ctx.runQuery(internal.careerActions.queries.getFullProfile, { profileId })`
         b. If no profile, log error and return
         c. Fetch existing matches for growth areas: `ctx.runQuery(internal.matching.queries.getExistingMatches, { profileId })` — extract `recommendations` arrays, aggregate skill/experience items
         d. Fetch preserved actions: `ctx.runQuery(internal.careerActions.queries.getPreservedActions, { profileId })`
         e. Build profile context string using `buildProfileContext(profile)` (imported from matching/prompts)
         f. Build user message using `buildActionGenerationContext(profileContext, growthAreas, preservedActions)`
         g. Create Anthropic client: `new Anthropic()`
         h. Call `anthropic.messages.create` with:
            - `model: MODEL_VERSION`
            - `max_tokens: 4096`
            - `tools: [generateCareerActionsTool]`
            - `tool_choice: { type: 'tool', name: 'generate_career_actions' }` (per locked decision #3)
            - `system: ACTION_GENERATION_SYSTEM_PROMPT`
            - `messages: [{ role: 'user', content: contextString }]`
         i. Extract tool_use block from response
         j. Validate with `actionResultSchema.safeParse(toolUse.input)` — shadow mode (log errors, accept data)
         k. Call `ctx.runMutation(internal.careerActions.mutations.saveGeneratedActions, { profileId, actions: result.actions, modelVersion: MODEL_VERSION })`
         l. Log success with action count

       - Wrap entire handler in try/catch. On error, log via `log('error', ...)` and return (do NOT throw — action generation failing should not surface errors to user since it's fire-and-forget via scheduler)

2. Modify `convex/matches.ts` `triggerMatchComputation`:
   - Add import: `import { internal } from './_generated/api'` (if not already imported — check first, it IS already imported)
   - After the existing `await ctx.runAction(internal.matching.compute.computeMatchesForProfile, { profileId: profile._id })` line, add:
     ```
     // Generate career actions in parallel (fire-and-forget via scheduler)
     await ctx.scheduler.runAfter(
       0,
       internal.careerActions.compute.computeActionsForProfile,
       { profileId: profile._id },
     )
     ```
   - Per locked decision #2: this runs in parallel, not chained. The scheduler call is non-blocking.
   - NOTE: The scheduler call goes BEFORE the `return result` line but AFTER the `await ctx.runAction(...)` for matching. The matching action is awaited (blocks until done for the UI loading state), but action generation is scheduled fire-and-forget.

Important: Do NOT add retry logic or rate limit handling for the action generation LLM call. Keep it simple — single attempt. If it fails, the user can refresh again. This differs from matching which has retries because matching is the primary feature.
</action>
<verify>

1. `npx convex dev --once` passes with no type errors
2. `bun run lint` passes
3. Check that `triggerMatchComputation` in convex/matches.ts contains `scheduler.runAfter` call to `careerActions.compute`
   </verify>
   <done>Haiku generates 3-5 personalized career actions in a single LLM call with forced tool_choice. Generation triggers automatically via scheduler when user refreshes matches. Failures are logged but don't affect match computation.</done>
   </task>

</tasks>

<verification>
1. `npx convex dev --once` passes — all careerActions functions register
2. `bun run lint` passes
3. Convex dashboard shows `careerActions.compute.computeActionsForProfile` function
4. `convex/matches.ts` contains `scheduler.runAfter` wiring to `careerActions.compute`
</verification>

<success_criteria>

- System prompt enforces personalization (no generic advice), anti-hallucination (no specific resources), and type variety (3+ types)
- Single Haiku call with forced tool_choice produces structured 3-5 action output
- Action generation runs fire-and-forget alongside matching via scheduler
- Growth areas from existing matches + preserved action context passed to LLM
- Failures logged silently without affecting match computation
  </success_criteria>

<output>
After completion, create `.planning/phases/35-generation/35-02-SUMMARY.md`
</output>
